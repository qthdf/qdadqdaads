{"README.md":"\n> Open this page at [https://chenq86.github.io/test2-extension/](https://chenq86.github.io/test2-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test2-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test2-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test2-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test2-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://chenq86.github.io/test2-extension/](https://chenq86.github.io/test2-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test2-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test2-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test2-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test2-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://chenq86.github.io/test2-extension/](https://chenq86.github.io/test2-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test2-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test2-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test2-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test2-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://chenq86.github.io/test3-extension/](https://chenq86.github.io/test3-extension/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/chenq86/test3-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/chenq86/test3-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/chenq86/test3-extension** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/chenq86/test3-extension/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"m#}mo}#+:_O[CEVfhsf4\">strip</variable><variable id=\"-GX;IFl`64[4W]00yQ6i\">strip2</variable></variables><block type=\"variables_set\" disabled=\"true\" x=\"-261\" y=\"-226\"><field name=\"VAR\" id=\"m#}mo}#+:_O[CEVfhsf4\">strip</field><value name=\"VALUE\"><shadow xmlns=\"http://www.w3.org/1999/xhtml\" type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neopixel_create\" disabled=\"true\"><field name=\"pin\">DigitalPin.P0</field><value name=\"numleds\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">24</field></shadow></value></block></value></block><block type=\"variables_set\" disabled=\"true\" x=\"-45\" y=\"-79\"><field name=\"VAR\" id=\"-GX;IFl`64[4W]00yQ6i\">strip2</field><value name=\"VALUE\"><shadow xmlns=\"http://www.w3.org/1999/xhtml\" type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neopixel_create\" disabled=\"true\"><field name=\"pin\">DigitalPin.P0</field><value name=\"numleds\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">24</field></shadow></value></block></value></block><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum PingUnit {\" line1=\"    //% block=&quot;微秒&quot;\" line2=\"    MicroSeconds,\" line3=\"    //% block=&quot;厘米&quot;\" line4=\"    Centimeters,\" line5=\"    //% block=&quot;英寸&quot;\" line6=\"    Inches\" line7=\"}\" numlines=\"8\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum PINs {\" line1=\"    P0,\" line2=\"    P1,\" line3=\"    P2,\" line4=\"    P3,\" line5=\"    P4,\" line6=\"    P5,\" line7=\"    P6,\" line8=\"    P7,\" line9=\"    P8,\" line10=\"    P9,\" line11=\"    P10,\" line12=\"    P11,\" line13=\"    P12,\" line14=\"    P13,\" line15=\"    P14,\" line16=\"    P15,\" line17=\"    P16,\" line18=\"    P19,\" line19=\"    P20\" line20=\"}\" numlines=\"21\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum TMP36Type {\" line1=\"    //% block=&quot;(℃)&quot; enumval=0\" line2=\"    TMP36_temperature_C,\" line3=\"\" line4=\"    //% block=&quot;(℉)&quot; enumval=1\" line5=\"    TMP36_temperature_F,\" line6=\"}\" numlines=\"7\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum RGB {\" line1=\"    //% block=&quot;红&quot;\" line2=\"    RED,\" line3=\"    //% block=&quot;绿&quot;\" line4=\"    GREEN,\" line5=\"    //% block=&quot;蓝&quot;\" line6=\"    BLUE,\" line7=\"    //% block=&quot;全部&quot;\" line8=\"    CLEAR\" line9=\"}\" numlines=\"10\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum NeoPixelColors {\" line1=\"    //% block=红\" line2=\"    Red = 0xFF0000,\" line3=\"    //% block=橙\" line4=\"    Orange = 0xFFA500,\" line5=\"    //% block=黄\" line6=\"    Yellow = 0xFFFF00,\" line7=\"    //% block=绿\" line8=\"    Green = 0x00FF00,\" line9=\"    //% block=蓝\" line10=\"    Blue = 0x0000FF,\" line11=\"    //% block=靛蓝\" line12=\"    Indigo = 0x4b0082,\" line13=\"    //% block=紫罗兰\" line14=\"    Violet = 0x8a2be2,\" line15=\"    //% block=紫\" line16=\"    Purple = 0xFF00FF,\" line17=\"    //% block=白\" line18=\"    White = 0xFFFFFF,\" line19=\"    //% block=黑\" line20=\"    Black = 0x000000\" line21=\"}\" numlines=\"22\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum NeoPixelMode {\" line1=\"    //% block=&quot;RGB (GRB 格式)&quot;\" line2=\"    RGB = 1,\" line3=\"    //% block=&quot;RGB+W&quot;\" line4=\"    RGBW = 2,\" line5=\"    //% block=&quot;RGB (RGB 格式)&quot;\" line6=\"    RGB_RGB = 3\" line7=\"}\" numlines=\"8\"></mutation><next><block type=\"typescript_statement\" editable=\"false\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Microbit {\" line1=\"\" line2=\"    export enum DHT11_state {\" line3=\"        //% block=&quot;温度(℃)&quot; enumval=0\" line4=\"        DHT11_temperature_C,\" line5=\"\" line6=\"        //% block=&quot;湿度(0~100)&quot; enumval=1\" line7=\"        DHT11_humidity,\" line8=\"    }\" line9=\"\" line10=\"    export enum Distance_Unit_List {\" line11=\"        //% block=&quot;厘米&quot; \" line12=\"        Distance_Unit_cm,\" line13=\"\" line14=\"        //% block=&quot;英寸&quot;\" line15=\"        Distance_Unit_inch,\" line16=\"    }\" line17=\"\" line18=\"\" line19=\"    //% blockId=&quot;readsoilmoisture&quot; block=&quot;土壤湿度传感器 %soilhumiditypin&quot;\" line20=\"    //% subcategory=传感器\" line21=\"    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {\" line22=\"        let voltage = 0;\" line23=\"        let soilmoisture = 0;\" line24=\"        voltage = pins.map(\" line25=\"            pins.analogReadPin(soilmoisturepin),\" line26=\"            0,\" line27=\"            1023,\" line28=\"            0,\" line29=\"            1023\" line30=\"        );\" line31=\"        soilmoisture = voltage;\" line32=\"        return Math.round(soilmoisture);\" line33=\"    }\" line34=\"    //% blockId=&quot;readlightintensity&quot; block=&quot;光敏传感器 %lightintensitypin&quot;\" line35=\"    //% subcategory=传感器\" line36=\"    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {\" line37=\"        let voltage2 = 0;\" line38=\"        let lightintensity = 0;\" line39=\"        voltage2 = pins.map(\" line40=\"            pins.analogReadPin(lightintensitypin),\" line41=\"            0,\" line42=\"            1023,\" line43=\"            0,\" line44=\"            1023\" line45=\"        );\" line46=\"        lightintensity = voltage2;\" line47=\"        return Math.round(1023 - lightintensity);\" line48=\"    }\" line49=\"    /**\" line50=\"    * toggle fans\" line51=\"    */\" line52=\"    //% blockId=fans block=&quot;电机风扇 %pin 切换至 $fanstate || 速度 %speed&quot;\" line53=\"    //% fanstate.shadow=&quot;toggleOnOff&quot;\" line54=\"    //% speed.min=0 speed.max=1023\" line55=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line56=\"    //% subcategory=执行器\" line57=\"    export function motorFan(pin: AnalogPin, fanstate: boolean, speed: number = 1023): void {\" line58=\"        if (fanstate) {\" line59=\"            pins.analogSetPeriod(pin, 1023)\" line60=\"            pins.analogWritePin(pin, Math.map(speed, 0, 1023, 0, 1023))\" line61=\"        }\" line62=\"        else {\" line63=\"            pins.analogWritePin(pin, 0)\" line64=\"            speed = 0\" line65=\"        }\" line66=\"    }\" line67=\"\" line68=\"    /**\" line69=\"    * get Ultrasonic distance\" line70=\"    */\" line71=\"    //% blockId=sonarbit\" line72=\"    //% distance_unit.fieldEditor=&quot;gridpicker&quot;\" line73=\"    //% distance_unit.fieldOptions.columns=2\" line74=\"    //% subcategory=传感器\" line75=\"    //% blockId=sonar_ping block=&quot;超声波传感器 echo %echo trig %trig 单位 %unit&quot;\" line76=\"    export function ping(trig: DigitalPin, echo: DigitalPin, unit: PingUnit, maxCmDistance = 500): number {\" line77=\"        // send pulse\" line78=\"        pins.setPull(trig, PinPullMode.PullNone);\" line79=\"        pins.digitalWritePin(trig, 0);\" line80=\"        control.waitMicros(2);\" line81=\"        pins.digitalWritePin(trig, 1);\" line82=\"        control.waitMicros(10);\" line83=\"        pins.digitalWritePin(trig, 0);\" line84=\"\" line85=\"        // read pulse\" line86=\"        const d = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);\" line87=\"\" line88=\"        switch (unit) {\" line89=\"            case PingUnit.Centimeters: return Math.idiv(d, 58);\" line90=\"            case PingUnit.Inches: return Math.idiv(d, 148);\" line91=\"            default: return d;\" line92=\"        }\" line93=\"    }\" line94=\"\" line95=\"    /**\" line96=\"    * toggle led\" line97=\"    */\" line98=\"    //% blockId=LEDR block=&quot;红色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;\" line99=\"    //% brightness.min=0 brightness.max=1023\" line100=\"    //% ledstate.shadow=&quot;toggleOnOff&quot;\" line101=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line102=\"    //% subcategory=执行器\" line103=\"    export function ledRBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\" line104=\"        if (ledstate) {\" line105=\"            pins.analogSetPeriod(pin, 1023)\" line106=\"            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\" line107=\"        }\" line108=\"        else {\" line109=\"            pins.analogWritePin(pin, 1023)\" line110=\"            brightness = 1023\" line111=\"        }\" line112=\"    }\" line113=\"\" line114=\"    /**\" line115=\"    * toggle led\" line116=\"    */\" line117=\"    //% blockId=LEDG block=&quot;绿色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;\" line118=\"    //% brightness.min=0 brightness.max=1023\" line119=\"    //% ledstate.shadow=&quot;toggleOnOff&quot;\" line120=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line121=\"    //% subcategory=执行器\" line122=\"    export function ledGBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\" line123=\"        if (ledstate) {\" line124=\"            pins.analogSetPeriod(pin, 1023)\" line125=\"            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\" line126=\"        }\" line127=\"        else {\" line128=\"            pins.analogWritePin(pin, 1023)\" line129=\"            brightness = 1023\" line130=\"        }\" line131=\"    }\" line132=\"\" line133=\"    /**\" line134=\"    * toggle led\" line135=\"    */\" line136=\"    //% blockId=LEDB block=&quot;蓝色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;\" line137=\"    //% brightness.min=0 brightness.max=1023\" line138=\"    //% ledstate.shadow=&quot;toggleOnOff&quot;\" line139=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line140=\"    //% subcategory=执行器\" line141=\"    export function ledBBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\" line142=\"        if (ledstate) {\" line143=\"            pins.analogSetPeriod(pin, 1023)\" line144=\"            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\" line145=\"        }\" line146=\"        else {\" line147=\"            pins.analogWritePin(pin, 1023)\" line148=\"            brightness = 1023\" line149=\"        }\" line150=\"    }\" line151=\"\" line152=\"    /**\" line153=\"    * toggle led\" line154=\"    */\" line155=\"    //% blockId=LEDY block=&quot;黄色 LED %pin 切换到 $ledstate || 亮度 %brightness&quot;\" line156=\"    //% brightness.min=0 brightness.max=1023\" line157=\"    //% ledstate.shadow=&quot;toggleOnOff&quot;\" line158=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line159=\"    //% subcategory=执行器\" line160=\"    export function ledYBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\" line161=\"        if (ledstate) {\" line162=\"            pins.analogSetPeriod(pin, 1023)\" line163=\"            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\" line164=\"        }\" line165=\"        else {\" line166=\"            pins.analogWritePin(pin, 1023)\" line167=\"            brightness = 1023\" line168=\"        }\" line169=\"    }\" line170=\"\" line171=\"    const PCA9685_ADD = 0x40\" line172=\"    const MODE1 = 0x00\" line173=\"    const LED0_ON_L = 0x06\" line174=\"    const PRESCALE = 0xFE\" line175=\"\" line176=\"    let initialized = false\" line177=\"\" line178=\"    export enum enPos {\" line179=\"        //% blockId=&quot;forward&quot; block=&quot;前进&quot;\" line180=\"        forward = 1,\" line181=\"        //% blockId=&quot;stop&quot; block=&quot;后退&quot;\" line182=\"        stop = 2\" line183=\"    }\" line184=\"\" line185=\"    export enum enServo {\" line186=\"        S1 = 0,\" line187=\"        S2,\" line188=\"        S3,\" line189=\"        S4\" line190=\"    }\" line191=\"\" line192=\"    export enum enMotors {\" line193=\"        M1 = 8,\" line194=\"        M2 = 10,\" line195=\"        M3 = 12,\" line196=\"        M4 = 14\" line197=\"    }\" line198=\"\" line199=\"    function i2cwrite(addr: number, reg: number, value: number) {\" line200=\"        let buf = pins.createBuffer(2)\" line201=\"        buf[0] = reg\" line202=\"        buf[1] = value\" line203=\"        pins.i2cWriteBuffer(addr, buf)\" line204=\"    }\" line205=\"\" line206=\"    function i2cread(addr: number, reg: number) {\" line207=\"        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\" line208=\"        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\" line209=\"        return val;\" line210=\"    }\" line211=\"\" line212=\"    function initPCA9685(): void {\" line213=\"        i2cwrite(PCA9685_ADD, MODE1, 0x00)\" line214=\"        setFreq(50);\" line215=\"    }\" line216=\"\" line217=\"    function setFreq(freq: number): void {\" line218=\"        // Constrain the frequency\" line219=\"        let prescaleval = 25000000;\" line220=\"        prescaleval /= 4096;\" line221=\"        prescaleval /= freq;\" line222=\"        prescaleval -= 1;\" line223=\"        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\" line224=\"        let oldmode = i2cread(PCA9685_ADD, MODE1);\" line225=\"        let newmode = (oldmode &amp; 0x7F) | 0x10; // sleep\" line226=\"        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\" line227=\"        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\" line228=\"        i2cwrite(PCA9685_ADD, MODE1, oldmode);\" line229=\"        control.waitMicros(5000);\" line230=\"        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\" line231=\"    }\" line232=\"\" line233=\"    function setPwm(channel: number, on: number, off: number): void {\" line234=\"        if (channel &lt; 0 || channel &gt; 15)\" line235=\"            return;\" line236=\"        if (!initialized) {\" line237=\"            initPCA9685();\" line238=\"        }\" line239=\"        let buf2 = pins.createBuffer(5);\" line240=\"        buf2[0] = LED0_ON_L + 4 * channel;\" line241=\"        buf2[1] = on &amp; 0xff;\" line242=\"        buf2[2] = (on &gt;&gt; 8) &amp; 0xff;\" line243=\"        buf2[3] = off &amp; 0xff;\" line244=\"        buf2[4] = (off &gt;&gt; 8) &amp; 0xff;\" line245=\"        pins.i2cWriteBuffer(PCA9685_ADD, buf2);\" line246=\"    }\" line247=\"\" line248=\"    //% blockId=SuperBit_Servo4 block=&quot;Geek舵机| %num|角度 %value&quot;\" line249=\"    //% num.min=1 num.max=4 value.min=0 value.max=300\" line250=\"    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=20\" line251=\"    //% subcategory=执行器\" line252=\"    export function Servo4(num: enServo, value: number): void {\" line253=\"\" line254=\"        // 50hz: 20,000 us\" line255=\"        let us = (value * 1800 * 0.6 / 180 + 600); // 0.6 ~ 2.4\" line256=\"        let pwm = us * 4096 / 20000;\" line257=\"        setPwm(num, 0, pwm);\" line258=\"\" line259=\"    }\" line260=\"\" line261=\"    //% blockId=SuperBit_MotorRun block=&quot;电机|%index|速度(-255~255) %speed&quot;\" line262=\"    //% speed.min=-255 speed.max=255\" line263=\"    //% subcategory=执行器\" line264=\"    export function MotorRun(index: enMotors, speed: number): void {\" line265=\"        if (!initialized) {\" line266=\"            initPCA9685()\" line267=\"        }\" line268=\"        speed = speed * 16; // map 255 to 4096\" line269=\"        if (speed &gt;= 4096) {\" line270=\"            speed = 4095\" line271=\"        }\" line272=\"        if (speed &lt;= -4096) {\" line273=\"            speed = -4095\" line274=\"        }\" line275=\"\" line276=\"        let a = index\" line277=\"        let b = index + 1\" line278=\"\" line279=\"        if (a &gt; 10) {\" line280=\"            if (speed &gt;= 0) {\" line281=\"                setPwm(a, 0, speed)\" line282=\"                setPwm(b, 0, 0)\" line283=\"            } else {\" line284=\"                setPwm(a, 0, 0)\" line285=\"                setPwm(b, 0, -speed)\" line286=\"            }\" line287=\"        }\" line288=\"        else {\" line289=\"            if (speed &gt;= 0) {\" line290=\"                setPwm(b, 0, speed)\" line291=\"                setPwm(a, 0, 0)\" line292=\"            } else {\" line293=\"                setPwm(b, 0, 0)\" line294=\"                setPwm(a, 0, -speed)\" line295=\"            }\" line296=\"        }\" line297=\"    }\" line298=\"\" line299=\"    //% blockId=&quot;elecmagnet&quot; block=&quot;电磁铁 %pin 切换至 %magState || 磁力 %force&quot;\" line300=\"    //% magState.shadow=&quot;toggleOnOff&quot;\" line301=\"    //% force.min=0 force.max=1023\" line302=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line303=\"    //% subcategory=执行器\" line304=\"    export function elecmagnet(pin: AnalogPin, magState: boolean, force: number = 1023): void {\" line305=\"\" line306=\"        if (magState) {\" line307=\"            pins.analogSetPeriod(pin, 1023)\" line308=\"            pins.analogWritePin(pin, Math.map(force, 0, 1023, 0, 1023))\" line309=\"        }\" line310=\"        else {\" line311=\"            pins.analogWritePin(pin, 0)\" line312=\"            force = 0\" line313=\"        }\" line314=\"    }\" line315=\"    //% blockId=&quot;pinpullup&quot; block=&quot;巡线传感器 %pin 引脚为上拉&quot;\" line316=\"    //% subcategory=执行器\" line317=\"    export function pinpullup(pin: PINs): void {\" line318=\"        switch (pin) {\" line319=\"            case PINs.P0: pins.setPull(DigitalPin.P0, PinPullMode.PullUp);\" line320=\"            case PINs.P1: pins.setPull(DigitalPin.P1, PinPullMode.PullUp);\" line321=\"            case PINs.P2: pins.setPull(DigitalPin.P2, PinPullMode.PullUp);\" line322=\"            case PINs.P3: pins.setPull(DigitalPin.P3, PinPullMode.PullUp);\" line323=\"            case PINs.P4: pins.setPull(DigitalPin.P4, PinPullMode.PullUp);\" line324=\"            case PINs.P5: pins.setPull(DigitalPin.P5, PinPullMode.PullUp);\" line325=\"            case PINs.P6: pins.setPull(DigitalPin.P6, PinPullMode.PullUp);\" line326=\"            case PINs.P7: pins.setPull(DigitalPin.P7, PinPullMode.PullUp);\" line327=\"            case PINs.P8: pins.setPull(DigitalPin.P8, PinPullMode.PullUp);\" line328=\"            case PINs.P9: pins.setPull(DigitalPin.P9, PinPullMode.PullUp);\" line329=\"            case PINs.P10: pins.setPull(DigitalPin.P10, PinPullMode.PullUp);\" line330=\"            case PINs.P11: pins.setPull(DigitalPin.P11, PinPullMode.PullUp);\" line331=\"            case PINs.P12: pins.setPull(DigitalPin.P12, PinPullMode.PullUp);\" line332=\"            case PINs.P13: pins.setPull(DigitalPin.P13, PinPullMode.PullUp);\" line333=\"            case PINs.P14: pins.setPull(DigitalPin.P14, PinPullMode.PullUp);\" line334=\"            case PINs.P15: pins.setPull(DigitalPin.P15, PinPullMode.PullUp);\" line335=\"            case PINs.P16: pins.setPull(DigitalPin.P16, PinPullMode.PullUp);\" line336=\"            case PINs.P19: pins.setPull(DigitalPin.P19, PinPullMode.PullUp);\" line337=\"            case PINs.P20: pins.setPull(DigitalPin.P20, PinPullMode.PullUp);\" line338=\"        }\" line339=\"\" line340=\"\" line341=\"    }\" line342=\"\" line343=\"    //% blockId=&quot;laser_controller&quot; block=&quot;激光 %pin 切换至 %laserState || 激光 %intensity&quot;\" line344=\"    //% laserState.shadow=&quot;toggleOnOff&quot;\" line345=\"    //% intensity.min=0 intensity.max=1023\" line346=\"    //% expandableArgumentMode=&quot;toggle&quot;\" line347=\"    //% subcategory=执行器\" line348=\"    export function laserController(pin: AnalogPin, laserState: boolean, intensity: number = 1023): void {\" line349=\"\" line350=\"        if (laserState) {\" line351=\"            pins.analogSetPeriod(pin, 1023)\" line352=\"            pins.analogWritePin(pin, Math.map(intensity, 0, 1023, 0, 1023))\" line353=\"        }\" line354=\"        else {\" line355=\"            pins.analogWritePin(pin, 0)\" line356=\"            intensity = 0\" line357=\"        }\" line358=\"    }\" line359=\"\" line360=\"    //% blockId=&quot;octopus_ReadWaterLevel&quot; block=&quot;水位传感器 %waterlevelpin&quot;\" line361=\"    //% subcategory=传感器\" line362=\"    export function ReadWaterLevel(waterlevelpin: AnalogPin): number {\" line363=\"        let voltage4 = 0;\" line364=\"        let waterLevel = 0;\" line365=\"        voltage4 = pins.map(\" line366=\"            pins.analogReadPin(waterlevelpin),\" line367=\"            0,\" line368=\"            1023,\" line369=\"            0,\" line370=\"            1023\" line371=\"        );\" line372=\"        waterLevel = voltage4;\" line373=\"        return Math.round(waterLevel);\" line374=\"    }\" line375=\"\" line376=\"    //% blockId=&quot;ReadGasConcentration&quot; block=&quot;可燃气体传感器 %gasconcentrationpin&quot;\" line377=\"    //% subcategory=传感器\" line378=\"    export function ReadGasConcentration(gasconcentrationpin: AnalogPin): number {\" line379=\"        let voltage5 = 0;\" line380=\"        let gasConcentration = 0;\" line381=\"        voltage5 = pins.map(\" line382=\"            pins.analogReadPin(gasconcentrationpin),\" line383=\"            0,\" line384=\"            1023,\" line385=\"            0,\" line386=\"            1023\" line387=\"        );\" line388=\"        gasConcentration = voltage5;\" line389=\"        return Math.round(gasConcentration);\" line390=\"    }\" line391=\"\" line392=\"    //% blockId=&quot;Readflame&quot; block=&quot;火焰传感器 %flamepin&quot;\" line393=\"    //% subcategory=传感器\" line394=\"    export function Readflame(flamepin: AnalogPin): number {\" line395=\"        let voltage6 = 0;\" line396=\"        let flame = 0;\" line397=\"        voltage6 = pins.map(\" line398=\"            pins.analogReadPin(flamepin),\" line399=\"            0,\" line400=\"            1023,\" line401=\"            0,\" line402=\"            1023\" line403=\"        );\" line404=\"        flame = voltage6;\" line405=\"        return Math.round(flame);\" line406=\"    }\" line407=\"\" line408=\"    //% blockId=&quot;ReadGrayLevel&quot; block=&quot;灰度传感器 %graylevelpin&quot;\" line409=\"    //% subcategory=传感器\" line410=\"    export function ReadGrayLevel(graylevelpin: AnalogPin): number {\" line411=\"        let voltage7 = 0;\" line412=\"        let grayLevel = 0;\" line413=\"        voltage7 = pins.map(\" line414=\"            pins.analogReadPin(graylevelpin),\" line415=\"            0,\" line416=\"            1023,\" line417=\"            80,\" line418=\"            1023\" line419=\"        );\" line420=\"        grayLevel = voltage7;\" line421=\"        return Math.round(grayLevel);\" line422=\"    }\" line423=\"\" line424=\"    //% blockId=&quot;readWaterTemp&quot; block=&quot;防水温度传感器 %waterproofpin&quot;\" line425=\"    //% subcategory=传感器\" line426=\"    export function readWaterTemp(waterproofpin: AnalogPin): number {\" line427=\"        let voltage22 = 0;\" line428=\"        let waterProofTemp = 0;\" line429=\"        voltage22 = pins.map(\" line430=\"            pins.analogReadPin(waterproofpin),\" line431=\"            0,\" line432=\"            1023,\" line433=\"            0,\" line434=\"            1023\" line435=\"        );\" line436=\"        waterProofTemp = voltage22;\" line437=\"        return Math.round(1023 - waterProofTemp);\" line438=\"    }\" line439=\"\" line440=\"    //% blockId=potentiometerRead\" line441=\"    //% block=&quot;电位器 %pin&quot;\" line442=\"    //% subcategory=传感器\" line443=\"    export function potentiometerRead(pin: AnalogPin): number {\" line444=\"        return pins.analogReadPin(pin);\" line445=\"    }\" line446=\"\" line447=\"    //% blockId=buttonState\" line448=\"    //% block=&quot;按钮传感器 %pin&quot;\" line449=\"    //% subcategory=传感器\" line450=\"    export function buttonState(pin: DigitalPin): number {\" line451=\"\" line452=\"        return pins.digitalReadPin(pin);\" line453=\"    }\" line454=\"    //% blockId=followState\" line455=\"    //% block=&quot;巡线传感器 %pin&quot;\" line456=\"    //% subcategory=传感器\" line457=\"    export function followState(pin: PINs): number {\" line458=\"        switch (pin) {\" line459=\"            case PINs.P0: return pins.digitalReadPin(DigitalPin.P0);\" line460=\"            case PINs.P1: return pins.digitalReadPin(DigitalPin.P1);\" line461=\"            case PINs.P2: return pins.digitalReadPin(DigitalPin.P2);\" line462=\"            case PINs.P3: return pins.digitalReadPin(DigitalPin.P3);\" line463=\"            case PINs.P4: return pins.digitalReadPin(DigitalPin.P4);\" line464=\"            case PINs.P5: return pins.digitalReadPin(DigitalPin.P5);\" line465=\"            case PINs.P6: return pins.digitalReadPin(DigitalPin.P6);\" line466=\"            case PINs.P7: return pins.digitalReadPin(DigitalPin.P7);\" line467=\"            case PINs.P8: return pins.digitalReadPin(DigitalPin.P8);\" line468=\"            case PINs.P9: return pins.digitalReadPin(DigitalPin.P9);\" line469=\"            case PINs.P10: return pins.digitalReadPin(DigitalPin.P10);\" line470=\"            case PINs.P11: return pins.digitalReadPin(DigitalPin.P11);\" line471=\"            case PINs.P12: return pins.digitalReadPin(DigitalPin.P12);\" line472=\"            case PINs.P13: return pins.digitalReadPin(DigitalPin.P13);\" line473=\"            case PINs.P14: return pins.digitalReadPin(DigitalPin.P14);\" line474=\"            case PINs.P15: return pins.digitalReadPin(DigitalPin.P15);\" line475=\"            case PINs.P16: return pins.digitalReadPin(DigitalPin.P16);\" line476=\"            case PINs.P19: return pins.digitalReadPin(DigitalPin.P19);\" line477=\"            case PINs.P20: return pins.digitalReadPin(DigitalPin.P20);\" line478=\"\" line479=\"        }\" line480=\"\" line481=\"    }\" line482=\"\" line483=\"    //% blockId=farState\" line484=\"    //% block=&quot;远距离光电传感器 %pin&quot;\" line485=\"    //% subcategory=传感器\" line486=\"    export function farState(pin: DigitalPin): number {\" line487=\"        return pins.digitalReadPin(pin);\" line488=\"    }\" line489=\"\" line490=\"    //% blockId=hState\" line491=\"    //% block=&quot;霍尔传感器 %pin&quot;\" line492=\"    //% subcategory=传感器\" line493=\"    export function hState(pin: DigitalPin): number {\" line494=\"        return pins.digitalReadPin(pin);\" line495=\"    }\" line496=\"\" line497=\"    enum LCS_Constants {\" line498=\"        // Constants\" line499=\"        ADDRESS = 0x29,\" line500=\"        ID = 0x12, // Register should be equal to 0x44 for the TCS34721 or TCS34725, or 0x4D for the TCS34723 or TCS34727.\" line501=\"\" line502=\"        COMMAND_BIT = 0x80,\" line503=\"\" line504=\"        ENABLE = 0x00,\" line505=\"        ENABLE_AIEN = 0x10, // RGBC Interrupt Enable\" line506=\"        ENABLE_WEN = 0x08, // Wait enable - Writing 1 activates the wait timer\" line507=\"        ENABLE_AEN = 0x02, // RGBC Enable - Writing 1 actives the ADC, 0 disables it\" line508=\"        ENABLE_PON = 0x01, // Power on - Writing 1 activates the internal oscillator, 0 disables it\" line509=\"        ATIME = 0x01, // Integration time\" line510=\"        WTIME = 0x03, // Wait time (if ENABLE_WEN is asserted)\" line511=\"        AILTL = 0x04, // Clear channel lower interrupt threshold\" line512=\"        AILTH = 0x05,\" line513=\"        AIHTL = 0x06, // Clear channel upper interrupt threshold\" line514=\"        AIHTH = 0x07,\" line515=\"        PERS = 0x0C, // Persistence register - basic SW filtering mechanism for interrupts\" line516=\"        PERS_NONE = 0x00, // Every RGBC cycle generates an interrupt\" line517=\"        PERS_1_CYCLE = 0x01, // 1 clean channel value outside threshold range generates an interrupt\" line518=\"        PERS_2_CYCLE = 0x02, // 2 clean channel values outside threshold range generates an interrupt\" line519=\"        PERS_3_CYCLE = 0x03, // 3 clean channel values outside threshold range generates an interrupt\" line520=\"        PERS_5_CYCLE = 0x04, // 5 clean channel values outside threshold range generates an interrupt\" line521=\"        PERS_10_CYCLE = 0x05, // 10 clean channel values outside threshold range generates an interrupt\" line522=\"        PERS_15_CYCLE = 0x06, // 15 clean channel values outside threshold range generates an interrupt\" line523=\"        PERS_20_CYCLE = 0x07, // 20 clean channel values outside threshold range generates an interrupt\" line524=\"        PERS_25_CYCLE = 0x08, // 25 clean channel values outside threshold range generates an interrupt\" line525=\"        PERS_30_CYCLE = 0x09, // 30 clean channel values outside threshold range generates an interrupt\" line526=\"        PERS_35_CYCLE = 0x0A, // 35 clean channel values outside threshold range generates an interrupt\" line527=\"        PERS_40_CYCLE = 0x0B, // 40 clean channel values outside threshold range generates an interrupt\" line528=\"        PERS_45_CYCLE = 0x0C, // 45 clean channel values outside threshold range generates an interrupt\" line529=\"        PERS_50_CYCLE = 0x0D, // 50 clean channel values outside threshold range generates an interrupt\" line530=\"        PERS_55_CYCLE = 0x0E, // 55 clean channel values outside threshold range generates an interrupt\" line531=\"        PERS_60_CYCLE = 0x0F, // 60 clean channel values outside threshold range generates an interrupt\" line532=\"        CONFIG = 0x0D,\" line533=\"        CONFIG_WLONG = 0x02, // Choose between short and long (12x) wait times via WTIME\" line534=\"        CONTROL = 0x0F, // Set the gain level for the sensor\" line535=\"        STATUS = 0x13,\" line536=\"        STATUS_AINT = 0x10, // RGBC Clean channel interrupt\" line537=\"        STATUS_AVALID = 0x01, // Indicates that the RGBC channels have completed an integration cycle\" line538=\"\" line539=\"        CDATAL = 0x14, // Clear channel data\" line540=\"        CDATAH = 0x15,\" line541=\"        RDATAL = 0x16, // Red channel data\" line542=\"        RDATAH = 0x17,\" line543=\"        GDATAL = 0x18, // Green channel data\" line544=\"        GDATAH = 0x19,\" line545=\"        BDATAL = 0x1A, // Blue channel data\" line546=\"        BDATAH = 0x1B,\" line547=\"\" line548=\"        GAIN_1X = 0x00, //  1x gain\" line549=\"        GAIN_4X = 0x01, //  4x gain\" line550=\"        GAIN_16X = 0x02, // 16x gain\" line551=\"        GAIN_60X = 0x03  // 60x gain\" line552=\"    }\" line553=\"\" line554=\"    let LCS_integration_time_val = 0\" line555=\"\" line556=\"    // I2C functions\" line557=\"\" line558=\"    function I2C_WriteReg8(addr: number, reg: number, val: number) {\" line559=\"        let buf3 = pins.createBuffer(2)\" line560=\"        buf3.setNumber(NumberFormat.UInt8BE, 0, reg)\" line561=\"        buf3.setNumber(NumberFormat.UInt8BE, 1, val)\" line562=\"        pins.i2cWriteBuffer(addr, buf3)\" line563=\"    }\" line564=\"\" line565=\"    function I2C_ReadReg8(addr: number, reg: number): number {\" line566=\"        let buf4 = pins.createBuffer(1)\" line567=\"        buf4.setNumber(NumberFormat.UInt8BE, 0, reg)\" line568=\"        pins.i2cWriteBuffer(addr, buf4)\" line569=\"        buf4 = pins.i2cReadBuffer(addr, 1)\" line570=\"        return buf4.getNumber(NumberFormat.UInt8BE, 0);\" line571=\"    }\" line572=\"\" line573=\"    function I2C_ReadReg16(addr: number, reg: number): number {\" line574=\"        let buf5 = pins.createBuffer(1)\" line575=\"        buf5.setNumber(NumberFormat.UInt8BE, 0, reg)\" line576=\"        pins.i2cWriteBuffer(addr, buf5)\" line577=\"        buf5 = pins.i2cReadBuffer(addr, 2)\" line578=\"        // Little endian\" line579=\"        return ((buf5.getNumber(NumberFormat.UInt8BE, 1) &lt;&lt; 8) | buf5.getNumber(NumberFormat.UInt8BE, 0));\" line580=\"    }\" line581=\"    function LCS_get_raw_data(delay: boolean = false): number[] {\" line582=\"        if (delay) {\" line583=\"            // Delay for the integration time to allow reading immediately after the previous read.\" line584=\"            basic.pause((256 - LCS_integration_time_val) * 2.4)\" line585=\"        }\" line586=\"\" line587=\"        let div = (256 - LCS_integration_time_val) * 1024\" line588=\"        let rgbc = [0, 0, 0, 0]\" line589=\"        rgbc[0] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL)) / div\" line590=\"        rgbc[1] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL)) / div\" line591=\"        rgbc[2] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL)) / div\" line592=\"        rgbc[3] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL)) / div\" line593=\"        if (rgbc[0] &gt; 1) {\" line594=\"            rgbc[0] = 1\" line595=\"        }\" line596=\"        if (rgbc[1] &gt; 1) {\" line597=\"            rgbc[1] = 1\" line598=\"        }\" line599=\"        if (rgbc[2] &gt; 1) {\" line600=\"            rgbc[2] = 1\" line601=\"        }\" line602=\"        if (rgbc[3] &gt; 1) {\" line603=\"            rgbc[3] = 1\" line604=\"        }\" line605=\"        return rgbc\" line606=\"    }\" line607=\"\" line608=\"    let font: number[] = [];\" line609=\"    font[0] = 0x0022d422;\" line610=\"    font[1] = 0x0022d422;\" line611=\"    font[2] = 0x0022d422;\" line612=\"    font[3] = 0x0022d422;\" line613=\"    font[4] = 0x0022d422;\" line614=\"    font[5] = 0x0022d422;\" line615=\"    font[6] = 0x0022d422;\" line616=\"    font[7] = 0x0022d422;\" line617=\"    font[8] = 0x0022d422;\" line618=\"    font[9] = 0x0022d422;\" line619=\"    font[10] = 0x0022d422;\" line620=\"    font[11] = 0x0022d422;\" line621=\"    font[12] = 0x0022d422;\" line622=\"    font[13] = 0x0022d422;\" line623=\"    font[14] = 0x0022d422;\" line624=\"    font[15] = 0x0022d422;\" line625=\"    font[16] = 0x0022d422;\" line626=\"    font[17] = 0x0022d422;\" line627=\"    font[18] = 0x0022d422;\" line628=\"    font[19] = 0x0022d422;\" line629=\"    font[20] = 0x0022d422;\" line630=\"    font[21] = 0x0022d422;\" line631=\"    font[22] = 0x0022d422;\" line632=\"    font[23] = 0x0022d422;\" line633=\"    font[24] = 0x0022d422;\" line634=\"    font[25] = 0x0022d422;\" line635=\"    font[26] = 0x0022d422;\" line636=\"    font[27] = 0x0022d422;\" line637=\"    font[28] = 0x0022d422;\" line638=\"    font[29] = 0x0022d422;\" line639=\"    font[30] = 0x0022d422;\" line640=\"    font[31] = 0x0022d422;\" line641=\"    font[32] = 0x00000000;\" line642=\"    font[33] = 0x000002e0;\" line643=\"    font[34] = 0x00018060;\" line644=\"    font[35] = 0x00afabea;\" line645=\"    font[36] = 0x00aed6ea;\" line646=\"    font[37] = 0x01991133;\" line647=\"    font[38] = 0x010556aa;\" line648=\"    font[39] = 0x00000060;\" line649=\"    font[40] = 0x000045c0;\" line650=\"    font[41] = 0x00003a20;\" line651=\"    font[42] = 0x00051140;\" line652=\"    font[43] = 0x00023880;\" line653=\"    font[44] = 0x00002200;\" line654=\"    font[45] = 0x00021080;\" line655=\"    font[46] = 0x00000100;\" line656=\"    font[47] = 0x00111110;\" line657=\"    font[48] = 0x0007462e;\" line658=\"    font[49] = 0x00087e40;\" line659=\"    font[50] = 0x000956b9;\" line660=\"    font[51] = 0x0005d629;\" line661=\"    font[52] = 0x008fa54c;\" line662=\"    font[53] = 0x009ad6b7;\" line663=\"    font[54] = 0x008ada88;\" line664=\"    font[55] = 0x00119531;\" line665=\"    font[56] = 0x00aad6aa;\" line666=\"    font[57] = 0x0022b6a2;\" line667=\"    font[58] = 0x00000140;\" line668=\"    font[59] = 0x00002a00;\" line669=\"    font[60] = 0x0008a880;\" line670=\"    font[61] = 0x00052940;\" line671=\"    font[62] = 0x00022a20;\" line672=\"    font[63] = 0x0022d422;\" line673=\"    font[64] = 0x00e4d62e;\" line674=\"    font[65] = 0x000f14be;\" line675=\"    font[66] = 0x000556bf;\" line676=\"    font[67] = 0x0008c62e;\" line677=\"    font[68] = 0x0007463f;\" line678=\"    font[69] = 0x0008d6bf;\" line679=\"    font[70] = 0x000094bf;\" line680=\"    font[71] = 0x00cac62e;\" line681=\"    font[72] = 0x000f909f;\" line682=\"    font[73] = 0x000047f1;\" line683=\"    font[74] = 0x0017c629;\" line684=\"    font[75] = 0x0008a89f;\" line685=\"    font[76] = 0x0008421f;\" line686=\"    font[77] = 0x01f1105f;\" line687=\"    font[78] = 0x01f4105f;\" line688=\"    font[79] = 0x0007462e;\" line689=\"    font[80] = 0x000114bf;\" line690=\"    font[81] = 0x000b6526;\" line691=\"    font[82] = 0x010514bf;\" line692=\"    font[83] = 0x0004d6b2;\" line693=\"    font[84] = 0x0010fc21;\" line694=\"    font[85] = 0x0007c20f;\" line695=\"    font[86] = 0x00744107;\" line696=\"    font[87] = 0x01f4111f;\" line697=\"    font[88] = 0x000d909b;\" line698=\"    font[89] = 0x00117041;\" line699=\"    font[90] = 0x0008ceb9;\" line700=\"    font[91] = 0x0008c7e0;\" line701=\"    font[92] = 0x01041041;\" line702=\"    font[93] = 0x000fc620;\" line703=\"    font[94] = 0x00010440;\" line704=\"    font[95] = 0x01084210;\" line705=\"    font[96] = 0x00000820;\" line706=\"    font[97] = 0x010f4a4c;\" line707=\"    font[98] = 0x0004529f;\" line708=\"    font[99] = 0x00094a4c;\" line709=\"    font[100] = 0x000fd288;\" line710=\"    font[101] = 0x000956ae;\" line711=\"    font[102] = 0x000097c4;\" line712=\"    font[103] = 0x0007d6a2;\" line713=\"    font[104] = 0x000c109f;\" line714=\"    font[105] = 0x000003a0;\" line715=\"    font[106] = 0x0006c200;\" line716=\"    font[107] = 0x0008289f;\" line717=\"    font[108] = 0x000841e0;\" line718=\"    font[109] = 0x01e1105e;\" line719=\"    font[110] = 0x000e085e;\" line720=\"    font[111] = 0x00064a4c;\" line721=\"    font[112] = 0x0002295e;\" line722=\"    font[113] = 0x000f2944;\" line723=\"    font[114] = 0x0001085c;\" line724=\"    font[115] = 0x00012a90;\" line725=\"    font[116] = 0x010a51e0;\" line726=\"    font[117] = 0x010f420e;\" line727=\"    font[118] = 0x00644106;\" line728=\"    font[119] = 0x01e8221e;\" line729=\"    font[120] = 0x00093192;\" line730=\"    font[121] = 0x00222292;\" line731=\"    font[122] = 0x00095b52;\" line732=\"    font[123] = 0x0008fc80;\" line733=\"    font[124] = 0x000003e0;\" line734=\"    font[125] = 0x000013f1;\" line735=\"    font[126] = 0x00841080;\" line736=\"    font[127] = 0x0022d422;\" line737=\"\" line738=\"    let _I2CAddr = 0;\" line739=\"    let _screen = pins.createBuffer(1025);\" line740=\"    let _buf2 = pins.createBuffer(2);\" line741=\"    let _buf3 = pins.createBuffer(3);\" line742=\"    let _buf4 = pins.createBuffer(4);\" line743=\"    let _ZOOM = 1;\" line744=\"\" line745=\"    function cmd1(d: number) {\" line746=\"        let n = d % 256;\" line747=\"        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);\" line748=\"    }\" line749=\"\" line750=\"    function cmd2(d1: number, d2: number) {\" line751=\"        _buf3[0] = 0;\" line752=\"        _buf3[1] = d1;\" line753=\"        _buf3[2] = d2;\" line754=\"        pins.i2cWriteBuffer(_I2CAddr, _buf3);\" line755=\"    }\" line756=\"\" line757=\"    function cmd3(d1: number, d2: number, d3: number) {\" line758=\"        _buf4[0] = 0;\" line759=\"        _buf4[1] = d1;\" line760=\"        _buf4[2] = d2;\" line761=\"        _buf4[3] = d3;\" line762=\"        pins.i2cWriteBuffer(_I2CAddr, _buf4);\" line763=\"    }\" line764=\"\" line765=\"    function set_pos(col: number = 0, page: number = 0) {\" line766=\"        cmd1(0xb0 | page) // page number\" line767=\"        let c = col * (_ZOOM + 1)\" line768=\"        cmd1(0x00 | (c % 16)) // lower start column address\" line769=\"        cmd1(0x10 | (c &gt;&gt; 4)) // upper start column address    \" line770=\"    }\" line771=\"\" line772=\"    // clear bit\" line773=\"    function clrbit(d: number, b: number): number {\" line774=\"        if (d &amp; (1 &lt;&lt; b))\" line775=\"            d -= (1 &lt;&lt; b)\" line776=\"        return d\" line777=\"    }\" line778=\"   \" line779=\"    /**\" line780=\"     * show text in OLED\" line781=\"     * @param x is X alis, eg: 0\" line782=\"     * @param y is Y alis, eg: 0\" line783=\"     * @param s is the text will be show, eg: 'Hello!'\" line784=\"     */\" line785=\"    //% blockId=&quot;OLED12864_I2C_SHOWSTRING1&quot; block=&quot;显示 文本 在 x %x|y %y|文本 %s&quot;\" line786=\"    //% parts=OLED12864_I2C trackArgs=0\" line787=\"    //% group=&quot;OLED显示屏&quot; subcategory=执行器\" line788=\"    //% weight=80 blockGap=10 color=#0855AA\" line789=\"    export function showString(x: number, y: number, s: string, color: number = 1) {\" line790=\"        let col2 = 0\" line791=\"        let q = 0\" line792=\"        let ind2 = 0\" line793=\"        for (let r = 0; r &lt; s.length; r++) {\" line794=\"            q = font[s.charCodeAt(r)]\" line795=\"            for (let k = 0; k &lt; 5; k++) {\" line796=\"                col2 = 0\" line797=\"                for (let l = 0; l &lt; 5; l++) {\" line798=\"                    if (q &amp; (1 &lt;&lt; (5 * k + l)))\" line799=\"                        col2 |= (1 &lt;&lt; (l + 1))\" line800=\"                }\" line801=\"                ind2 = (x + r) * 5 * (_ZOOM + 1) + y * 128 + k * (_ZOOM + 1) + 1\" line802=\"                if (color == 0)\" line803=\"                    col2 = 255 - col2\" line804=\"                _screen[ind2] = col2\" line805=\"                if (_ZOOM)\" line806=\"                    _screen[ind2 + 1] = col2\" line807=\"            }\" line808=\"        }\" line809=\"        set_pos(x * 5, y)\" line810=\"        let ind02 = x * 5 * (_ZOOM + 1) + y * 128\" line811=\"        let buf7 = _screen.slice(ind02, ind2 + 1)\" line812=\"        buf7[0] = 0x40\" line813=\"        pins.i2cWriteBuffer(_I2CAddr, buf7)\" line814=\"    }\" line815=\"\" line816=\"    /**\" line817=\"     * show a number in OLED\" line818=\"     * @param x is X alis, eg: 0\" line819=\"     * @param y is Y alis, eg: 0\" line820=\"     * @param num is the number will be show, eg: 12\" line821=\"     * @param color is number color, eg: 1\" line822=\"     */\" line823=\"    //% blockId=&quot;OLED12864_I2C_NUMBER&quot; block=&quot;显示 数字 在 x %x|y %y|数字 %num&quot;\" line824=\"    //% parts=OLED12864_I2C trackArgs=0\" line825=\"    //% group=&quot;OLED显示屏&quot; subcategory=执行器\" line826=\"    //% weight=80 blockGap=10 color=#0855AA\" line827=\"    export function showNumber(x: number, y: number, num: number, color: number = 1) {\" line828=\"        showString(x, y, num.toString(), color)\" line829=\"    }\" line830=\"\" line831=\"   \" line832=\"    export function draw() {\" line833=\"        set_pos()\" line834=\"        pins.i2cWriteBuffer(_I2CAddr, _screen)\" line835=\"    }\" line836=\"\" line837=\"    /**\" line838=\"     * clear screen\" line839=\"     */\" line840=\"    //% blockId=&quot;OLED12864_I2C_CLEAR&quot; block=&quot;清除&quot;\" line841=\"    //% parts=OLED12864_I2C trackArgs=0\" line842=\"    //% group=&quot;OLED显示屏&quot; subcategory=执行器\" line843=\"    //% weight=63 blockGap=10 color=#0855AA\" line844=\"    export function clear() {\" line845=\"        _screen.fill(0)\" line846=\"        _screen[0] = 0x40\" line847=\"        draw()\" line848=\"    }\" line849=\"\" line850=\"    /**\" line851=\"     * OLED initialize\" line852=\"     * @param addr is i2c addr, eg: 60\" line853=\"     */\" line854=\"    //% blockId=&quot;OLED12864_I2C_init&quot; block=&quot;初始化 OLED 地址为 %addr&quot;\" line855=\"    //% parts=OLED12864_I2C trackArgs=0\" line856=\"    //% weight=85 blockGap=10\" line857=\"    //% group=&quot;OLED显示屏&quot; subcategory=执行器\" line858=\"    //% blockGap=10  color=#0855AA\" line859=\"    export function init(addr: number) {\" line860=\"        _I2CAddr = addr;\" line861=\"        cmd1(0xAE)       // SSD1306_DISPLAYOFF\" line862=\"        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME\" line863=\"        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV\" line864=\"        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX\" line865=\"        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET\" line866=\"        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE\" line867=\"        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP\" line868=\"        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE\" line869=\"        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR\" line870=\"        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR\" line871=\"        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP\" line872=\"        cmd1(0xc8)       // SSD1306_COMSCANDEC\" line873=\"        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS\" line874=\"        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST\" line875=\"        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE\" line876=\"        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT\" line877=\"        cmd1(0xA6)       // SSD1306_NORMALDISPLAY\" line878=\"        cmd2(0xD6, 1)    // zoom on\" line879=\"        cmd1(0xAF)       // SSD1306_DISPLAYON\" line880=\"        clear()\" line881=\"        _ZOOM = 1\" line882=\"    }\" line883=\"\" line884=\"    /**\" line885=\"     * A NeoPixel strip\" line886=\"     */\" line887=\"    export class Strip {\" line888=\"        buf: Buffer;\" line889=\"        pin: DigitalPin;\" line890=\"        // TODO: encode as bytes instead of 32bit\" line891=\"        brightness: number;\" line892=\"        start: number; // start offset in LED strip\" line893=\"        _length: number; // number of LEDs\" line894=\"        _mode: NeoPixelMode;\" line895=\"        _matrixWidth: number; // number of leds in a matrix - if any\" line896=\"\" line897=\"        /**\" line898=\"         * Shows all LEDs to a given color (range 0-255 for r, g, b).\" line899=\"         * @param rgb RGB color of the LED\" line900=\"         */\" line901=\"        //% blockId=&quot;neopixel_set_strip_color&quot; block=&quot;%strip|显示 颜色 %rgb=neopixel_colors&quot;\" line902=\"        //% strip.defl=strip\" line903=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line904=\"        //% color=#2699BF blockGap=10\" line905=\"        showColor(rgb: number) {\" line906=\"            rgb = rgb &gt;&gt; 0;\" line907=\"            this.setAllRGB(rgb);\" line908=\"            this.show();\" line909=\"        }\" line910=\"\" line911=\"        /**\" line912=\"         * Shows a rainbow pattern on all LEDs.\" line913=\"         * @param startHue the start hue value for the rainbow, eg: 1\" line914=\"         * @param endHue the end hue value for the rainbow, eg: 360\" line915=\"         */\" line916=\"        //% blockId=&quot;neopixel_set_strip_rainbow&quot; block=&quot;%strip|显示 彩虹 从 %startHue|到 %endHue&quot;\" line917=\"        //% strip.defl=strip\" line918=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot; \" line919=\"        //% color=#2699BF blockGap=10\" line920=\"        showRainbow(startHue: number = 1, endHue: number = 360) {\" line921=\"            if (this._length &lt;= 0) return;\" line922=\"\" line923=\"            startHue = startHue &gt;&gt; 0;\" line924=\"            endHue = endHue &gt;&gt; 0;\" line925=\"            const saturation = 100;\" line926=\"            const luminance = 50;\" line927=\"            const steps = this._length;\" line928=\"            const direction = HueInterpolationDirection.Clockwise;\" line929=\"\" line930=\"            //hue\" line931=\"            const h1 = startHue;\" line932=\"            const h2 = endHue;\" line933=\"            const hDistCW = ((h2 + 360) - h1) % 360;\" line934=\"            const hStepCW = Math.idiv((hDistCW * 100), steps);\" line935=\"            const hDistCCW = ((h1 + 360) - h2) % 360;\" line936=\"            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\" line937=\"            let hStep: number;\" line938=\"            if (direction === HueInterpolationDirection.Clockwise) {\" line939=\"                hStep = hStepCW;\" line940=\"            } else if (direction === HueInterpolationDirection.CounterClockwise) {\" line941=\"                hStep = hStepCCW;\" line942=\"            } else {\" line943=\"                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;\" line944=\"            }\" line945=\"            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\" line946=\"\" line947=\"            //sat\" line948=\"            const s1 = saturation;\" line949=\"            const s2 = saturation;\" line950=\"            const sDist = s2 - s1;\" line951=\"            const sStep = Math.idiv(sDist, steps);\" line952=\"            const s1_100 = s1 * 100;\" line953=\"\" line954=\"            //lum\" line955=\"            const l1 = luminance;\" line956=\"            const l2 = luminance;\" line957=\"            const lDist = l2 - l1;\" line958=\"            const lStep = Math.idiv(lDist, steps);\" line959=\"            const l1_100 = l1 * 100\" line960=\"\" line961=\"            //interpolate\" line962=\"            if (steps === 1) {\" line963=\"                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\" line964=\"            } else {\" line965=\"                this.setPixelColor(0, hsl(startHue, saturation, luminance));\" line966=\"                for (let t = 1; t &lt; steps - 1; t++) {\" line967=\"                    const u = Math.idiv((h1_100 + t * hStep), 100) + 360;\" line968=\"                    const v = Math.idiv((s1_100 + t * sStep), 100);\" line969=\"                    const w = Math.idiv((l1_100 + t * lStep), 100);\" line970=\"                    this.setPixelColor(t, hsl(u, v, w));\" line971=\"                }\" line972=\"                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\" line973=\"            }\" line974=\"            this.show();\" line975=\"        }\" line976=\"\" line977=\"        \" line978=\"        /**\" line979=\"         * Set LED to a given color (range 0-255 for r, g, b).\" line980=\"         * You need to call ``show`` to make the changes visible.\" line981=\"         * @param pixeloffset position of the NeoPixel in the strip,eg: 1\" line982=\"         * @param rgb RGB color of the LED\" line983=\"         */\" line984=\"        //% blockId=&quot;neopixel_set_pixel_color&quot; block=&quot;%strip|设置 像素 颜色 在 %pixeloffset|到 %rgb=neopixel_colors&quot;\" line985=\"        //% strip.defl=strip\" line986=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line987=\"        //% color=#2699BF blockGap=10\" line988=\"        setPixelColor(pixeloffset: number, rgb: number): void {\" line989=\"            this.setPixelRGB(pixeloffset &gt;&gt; 0, rgb &gt;&gt; 0);\" line990=\"        }  \" line991=\"      \" line992=\"        /**\" line993=\"         * Send all the changes to the strip.\" line994=\"         */\" line995=\"        //% blockId=&quot;neopixel_show&quot; block=&quot;%strip|显示&quot;\" line996=\"        //% strip.defl=strip\" line997=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line998=\"        //% color=#2699BF blockGap=10\" line999=\"        show() {\" line1000=\"            // only supported in beta\" line1001=\"            // ws2812b.setBufferMode(this.pin, this._mode);\" line1002=\"            ws2812b.sendBuffer(this.buf, this.pin);\" line1003=\"        }\" line1004=\"\" line1005=\"        /**\" line1006=\"         * Turn off all LEDs.\" line1007=\"         * You need to call ``show`` to make the changes visible.\" line1008=\"         */\" line1009=\"        //% blockId=&quot;neopixel_clear&quot; block=&quot;%strip|清除&quot;\" line1010=\"        //% strip.defl=strip\" line1011=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line1012=\"        //% color=#2699BF blockGap=10\" line1013=\"        clear(): void {\" line1014=\"            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line1015=\"            this.buf.fill(0, this.start * stride, this._length * stride);\" line1016=\"        }\" line1017=\"\" line1018=\"        /**\" line1019=\"         * Set the brightness of the strip. This flag only applies to future operation.\" line1020=\"         * @param brightness a measure of LED brightness in 0-255. eg: 255\" line1021=\"         */\" line1022=\"        //% blockId=&quot;neopixel_set_brightness&quot; block=&quot;%strip|设置 亮度 %brightness&quot;\" line1023=\"        //% strip.defl=strip\" line1024=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line1025=\"        //% color=#2699BF blockGap=10\" line1026=\"        setBrightness(brightness: number): void {\" line1027=\"            this.brightness = brightness &amp; 0xff;\" line1028=\"        }\" line1029=\"\" line1030=\"        /**\" line1031=\"         * Set the pin where the neopixel is connected, defaults to P0.\" line1032=\"         */\" line1033=\"        //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line1034=\"        //% color=#2699BF blockGap=10\" line1035=\"        setPin(pin: DigitalPin): void {\" line1036=\"            this.pin = pin;\" line1037=\"            pins.digitalWritePin(this.pin, 0);\" line1038=\"            // don't yield to avoid races on initialization\" line1039=\"        }\" line1040=\"\" line1041=\"       \" line1042=\"\" line1043=\"        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\" line1044=\"            if (this._mode === NeoPixelMode.RGB_RGB) {\" line1045=\"                this.buf[offset + 0] = red;\" line1046=\"                this.buf[offset + 1] = green;\" line1047=\"            } else {\" line1048=\"                this.buf[offset + 0] = green;\" line1049=\"                this.buf[offset + 1] = red;\" line1050=\"            }\" line1051=\"            this.buf[offset + 2] = blue;\" line1052=\"        }\" line1053=\"\" line1054=\"        private setAllRGB(rgb: number) {\" line1055=\"            let red = unpackR(rgb);\" line1056=\"            let green = unpackG(rgb);\" line1057=\"            let blue = unpackB(rgb);\" line1058=\"\" line1059=\"            const br3 = this.brightness;\" line1060=\"            if (br3 &lt; 255) {\" line1061=\"                red = (red * br3) &gt;&gt; 8;\" line1062=\"                green = (green * br3) &gt;&gt; 8;\" line1063=\"                blue = (blue * br3) &gt;&gt; 8;\" line1064=\"            }\" line1065=\"            const end3 = this.start + this._length;\" line1066=\"            const stride6 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line1067=\"            for (let i5 = this.start; i5 &lt; end3; ++i5) {\" line1068=\"                this.setBufferRGB(i5 * stride6, red, green, blue)\" line1069=\"            }\" line1070=\"        }\" line1071=\"        private setAllW(white: number) {\" line1072=\"            if (this._mode !== NeoPixelMode.RGBW)\" line1073=\"                return;\" line1074=\"\" line1075=\"            let br4 = this.brightness;\" line1076=\"            if (br4 &lt; 255) {\" line1077=\"                white = (white * br4) &gt;&gt; 8;\" line1078=\"            }\" line1079=\"            let buf8 = this.buf;\" line1080=\"            let end4 = this.start + this._length;\" line1081=\"            for (let i6 = this.start; i6 &lt; end4; ++i6) {\" line1082=\"                let ledoffset3 = i6 * 4;\" line1083=\"                buf8[ledoffset3 + 3] = white;\" line1084=\"            }\" line1085=\"        }\" line1086=\"        private setPixelRGB(pixeloffset: number, rgb: number): void {\" line1087=\"            if (pixeloffset &lt; 0\" line1088=\"                || pixeloffset &gt;= this._length)\" line1089=\"                return;\" line1090=\"\" line1091=\"            let stride7 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line1092=\"            pixeloffset = (pixeloffset + this.start) * stride7;\" line1093=\"\" line1094=\"            let red2 = unpackR(rgb);\" line1095=\"            let green2 = unpackG(rgb);\" line1096=\"            let blue2 = unpackB(rgb);\" line1097=\"\" line1098=\"            let br5 = this.brightness;\" line1099=\"            if (br5 &lt; 255) {\" line1100=\"                red2 = (red2 * br5) &gt;&gt; 8;\" line1101=\"                green2 = (green2 * br5) &gt;&gt; 8;\" line1102=\"                blue2 = (blue2 * br5) &gt;&gt; 8;\" line1103=\"            }\" line1104=\"            this.setBufferRGB(pixeloffset, red2, green2, blue2)\" line1105=\"        }\" line1106=\"        private setPixelW(pixeloffset: number, white: number): void {\" line1107=\"            if (this._mode !== NeoPixelMode.RGBW)\" line1108=\"                return;\" line1109=\"\" line1110=\"            if (pixeloffset &lt; 0\" line1111=\"                || pixeloffset &gt;= this._length)\" line1112=\"                return;\" line1113=\"\" line1114=\"            pixeloffset = (pixeloffset + this.start) * 4;\" line1115=\"\" line1116=\"            let br6 = this.brightness;\" line1117=\"            if (br6 &lt; 255) {\" line1118=\"                white = (white * br6) &gt;&gt; 8;\" line1119=\"            }\" line1120=\"            let buf9 = this.buf;\" line1121=\"            buf9[pixeloffset + 3] = white;\" line1122=\"        }\" line1123=\"    }\" line1124=\"\" line1125=\"    /**\" line1126=\"     * Create a new NeoPixel driver for `numleds` LEDs.\" line1127=\"     * @param pin the pin where the neopixel is connected.\" line1128=\"     * @param numleds number of leds in the strip, eg: 8,30,60,64\" line1129=\"     */\" line1130=\"    //% blockId=&quot;neopixel_create&quot; block=&quot;灯环 在 端口 %pin|用 %numleds| leds&quot;\" line1131=\"    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line1132=\"    //% trackArgs=0,2\" line1133=\"    //% blockSetVariable=strip\" line1134=\"    //% color=#2699BF blockGap=10\" line1135=\"    //% weight=51\" line1136=\"    export function create(pin: DigitalPin, numleds: number): Strip {\" line1137=\"        let strip2 = new Strip();\" line1138=\"        let stride8 = NeoPixelMode.RGBW ? 4 : 3;\" line1139=\"        strip2.buf = pins.createBuffer(numleds * stride8);\" line1140=\"        strip2.start = 0;\" line1141=\"        strip2._length = numleds;\" line1142=\"        strip2._mode = NeoPixelMode.RGB;\" line1143=\"        strip2._matrixWidth = 0;\" line1144=\"        strip2.setBrightness(128)\" line1145=\"        strip2.setPin(pin)\" line1146=\"        return strip2;\" line1147=\"    }\" line1148=\"\" line1149=\"    /**\" line1150=\"     * Converts red, green, blue channels into a RGB color\" line1151=\"     * @param red value of the red channel between 0 and 255. eg: 255\" line1152=\"     * @param green value of the green channel between 0 and 255. eg: 255\" line1153=\"     * @param blue value of the blue channel between 0 and 255. eg: 255\" line1154=\"     */\" line1155=\"    //% blockId=&quot;neopixel_rgb&quot; block=&quot;红 %red|绿 %green|蓝 %blue&quot;\" line1156=\"    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line1157=\"    //% weight=32\" line1158=\"    //% color=#2699BF blockGap=10\" line1159=\"    export function rgb(red: number, green: number, blue: number): number {\" line1160=\"        return packRGB(red, green, blue);\" line1161=\"    }\" line1162=\"\" line1163=\"    /**\" line1164=\"     * Gets the RGB value of a known color\" line1165=\"    */\" line1166=\"    //% blockId=&quot;neopixel_colors&quot; block=&quot;%color&quot;\" line1167=\"    //% parts=&quot;neopixel&quot; subcategory=执行器 group=&quot;彩灯&quot;\" line1168=\"    //% weight=32\" line1169=\"    //% color=#2699BF blockGap=10\" line1170=\"    export function colors(color: NeoPixelColors): number {\" line1171=\"        return color;\" line1172=\"    }\" line1173=\"\" line1174=\"    function packRGB(a: number, b: number, c: number): number {\" line1175=\"        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);\" line1176=\"    }\" line1177=\"\" line1178=\"    function unpackR(rgb: number): number {\" line1179=\"        let r3 = (rgb &gt;&gt; 16) &amp; 0xFF;\" line1180=\"        return r3;\" line1181=\"    }\" line1182=\"\" line1183=\"    function unpackG(rgb: number): number {\" line1184=\"        let g3 = (rgb &gt;&gt; 8) &amp; 0xFF;\" line1185=\"        return g3;\" line1186=\"    }\" line1187=\"\" line1188=\"    function unpackB(rgb: number): number {\" line1189=\"        let b3 = (rgb) &amp; 0xFF;\" line1190=\"        return b3;\" line1191=\"    }\" line1192=\"\" line1193=\"    export function hsl(h: number, s: number, l: number): number {\" line1194=\"        h = Math.round(h);\" line1195=\"        s = Math.round(s);\" line1196=\"        l = Math.round(l);\" line1197=\"\" line1198=\"        h = h % 360;\" line1199=\"        s = Math.clamp(0, 99, s);\" line1200=\"        l = Math.clamp(0, 99, l);\" line1201=\"        let c2 = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]\" line1202=\"        let h12 = Math.idiv(h, 60);//[0,6]\" line1203=\"        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]\" line1204=\"        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);\" line1205=\"        let x = (c2 * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color\" line1206=\"        let r$: number;\" line1207=\"        let g$: number;\" line1208=\"        let b$: number;\" line1209=\"        if (h12 == 0) {\" line1210=\"            r$ = c2; g$ = x; b$ = 0;\" line1211=\"        } else if (h12 == 1) {\" line1212=\"            r$ = x; g$ = c2; b$ = 0;\" line1213=\"        } else if (h12 == 2) {\" line1214=\"            r$ = 0; g$ = c2; b$ = x;\" line1215=\"        } else if (h12 == 3) {\" line1216=\"            r$ = 0; g$ = x; b$ = c2;\" line1217=\"        } else if (h12 == 4) {\" line1218=\"            r$ = x; g$ = 0; b$ = c2;\" line1219=\"        } else if (h12 == 5) {\" line1220=\"            r$ = c2; g$ = 0; b$ = x;\" line1221=\"        }\" line1222=\"        let m2 = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c2), 2);\" line1223=\"        let r4 = r$ + m2;\" line1224=\"        let g4 = g$ + m2;\" line1225=\"        let b4 = b$ + m2;\" line1226=\"        return packRGB(r4, g4, b4);\" line1227=\"    }\" line1228=\"\" line1229=\"    export enum HueInterpolationDirection {\" line1230=\"        Clockwise,\" line1231=\"        CounterClockwise,\" line1232=\"        Shortest\" line1233=\"    }\" line1234=\"}\" numlines=\"1235\"></mutation></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type=\"neopixel_colors\" disabled=\"true\" x=\"392\" y=\"27\"><field name=\"color\">NeoPixelColors.Red</field></block></xml>","main.ts":"enum PingUnit {\n    //% block=\"微秒\"\n    MicroSeconds,\n    //% block=\"厘米\"\n    Centimeters,\n    //% block=\"英寸\"\n    Inches\n}\nenum PINs {\n    P0,\n    P1,\n    P2,\n    P3,\n    P4,\n    P5,\n    P6,\n    P7,\n    P8,\n    P9,\n    P10,\n    P11,\n    P12,\n    P13,\n    P14,\n    P15,\n    P16,\n    P19,\n    P20\n}\nenum TMP36Type {\n    //% block=\"(℃)\" enumval=0\n    TMP36_temperature_C,\n\n    //% block=\"(℉)\" enumval=1\n    TMP36_temperature_F,\n}\nenum RGB {\n    //% block=\"红\"\n    RED,\n    //% block=\"绿\"\n    GREEN,\n    //% block=\"蓝\"\n    BLUE,\n    //% block=\"全部\"\n    CLEAR\n}\nenum NeoPixelColors {\n    //% block=红\n    Red = 0xFF0000,\n    //% block=橙\n    Orange = 0xFFA500,\n    //% block=黄\n    Yellow = 0xFFFF00,\n    //% block=绿\n    Green = 0x00FF00,\n    //% block=蓝\n    Blue = 0x0000FF,\n    //% block=靛蓝\n    Indigo = 0x4b0082,\n    //% block=紫罗兰\n    Violet = 0x8a2be2,\n    //% block=紫\n    Purple = 0xFF00FF,\n    //% block=白\n    White = 0xFFFFFF,\n    //% block=黑\n    Black = 0x000000\n}\nenum NeoPixelMode {\n    //% block=\"RGB (GRB 格式)\"\n    RGB = 1,\n    //% block=\"RGB+W\"\n    RGBW = 2,\n    //% block=\"RGB (RGB 格式)\"\n    RGB_RGB = 3\n}\nnamespace Microbit {\n\n    export enum DHT11_state {\n        //% block=\"温度(℃)\" enumval=0\n        DHT11_temperature_C,\n\n        //% block=\"湿度(0~100)\" enumval=1\n        DHT11_humidity,\n    }\n\n    export enum Distance_Unit_List {\n        //% block=\"厘米\" \n        Distance_Unit_cm,\n\n        //% block=\"英寸\"\n        Distance_Unit_inch,\n    }\n\n\n    //% blockId=\"readsoilmoisture\" block=\"土壤湿度传感器 %soilhumiditypin\"\n    //% subcategory=传感器\n    export function ReadSoilHumidity(soilmoisturepin: AnalogPin): number {\n        let voltage = 0;\n        let soilmoisture = 0;\n        voltage = pins.map(\n            pins.analogReadPin(soilmoisturepin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        soilmoisture = voltage;\n        return Math.round(soilmoisture);\n    }\n    //% blockId=\"readlightintensity\" block=\"光敏传感器 %lightintensitypin\"\n    //% subcategory=传感器\n    export function ReadLightIntensity(lightintensitypin: AnalogPin): number {\n        let voltage2 = 0;\n        let lightintensity = 0;\n        voltage2 = pins.map(\n            pins.analogReadPin(lightintensitypin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        lightintensity = voltage2;\n        return Math.round(1023 - lightintensity);\n    }\n    /**\n    * toggle fans\n    */\n    //% blockId=fans block=\"电机风扇 %pin 切换至 $fanstate || 速度 %speed\"\n    //% fanstate.shadow=\"toggleOnOff\"\n    //% speed.min=0 speed.max=1023\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function motorFan(pin: AnalogPin, fanstate: boolean, speed: number = 1023): void {\n        if (fanstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(speed, 0, 1023, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            speed = 0\n        }\n    }\n\n    /**\n    * get Ultrasonic distance\n    */\n    //% blockId=sonarbit\n    //% distance_unit.fieldEditor=\"gridpicker\"\n    //% distance_unit.fieldOptions.columns=2\n    //% subcategory=传感器\n    //% blockId=sonar_ping block=\"超声波传感器 echo %echo trig %trig 单位 %unit\"\n    export function ping(trig: DigitalPin, echo: DigitalPin, unit: PingUnit, maxCmDistance = 500): number {\n        // send pulse\n        pins.setPull(trig, PinPullMode.PullNone);\n        pins.digitalWritePin(trig, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(trig, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(trig, 0);\n\n        // read pulse\n        const d = pins.pulseIn(echo, PulseValue.High, maxCmDistance * 58);\n\n        switch (unit) {\n            case PingUnit.Centimeters: return Math.idiv(d, 58);\n            case PingUnit.Inches: return Math.idiv(d, 148);\n            default: return d;\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDR block=\"红色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledRBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDG block=\"绿色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledGBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDB block=\"蓝色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledBBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    /**\n    * toggle led\n    */\n    //% blockId=LEDY block=\"黄色 LED %pin 切换到 $ledstate || 亮度 %brightness\"\n    //% brightness.min=0 brightness.max=1023\n    //% ledstate.shadow=\"toggleOnOff\"\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function ledYBrightness(pin: AnalogPin, ledstate: boolean, brightness: number = 1023): void {\n        if (ledstate) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(brightness, 1023, 0, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 1023)\n            brightness = 1023\n        }\n    }\n\n    const PCA9685_ADD = 0x40\n    const MODE1 = 0x00\n    const LED0_ON_L = 0x06\n    const PRESCALE = 0xFE\n\n    let initialized = false\n\n    export enum enPos {\n        //% blockId=\"forward\" block=\"前进\"\n        forward = 1,\n        //% blockId=\"stop\" block=\"后退\"\n        stop = 2\n    }\n\n    export enum enServo {\n        S1 = 0,\n        S2,\n        S3,\n        S4\n    }\n\n    export enum enMotors {\n        M1 = 8,\n        M2 = 10,\n        M3 = 12,\n        M4 = 14\n    }\n\n    function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    function initPCA9685(): void {\n        i2cwrite(PCA9685_ADD, MODE1, 0x00)\n        setFreq(50);\n    }\n\n    function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADD, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADD, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADD, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADD, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADD, MODE1, oldmode | 0xa1);\n    }\n\n    function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        if (!initialized) {\n            initPCA9685();\n        }\n        let buf2 = pins.createBuffer(5);\n        buf2[0] = LED0_ON_L + 4 * channel;\n        buf2[1] = on & 0xff;\n        buf2[2] = (on >> 8) & 0xff;\n        buf2[3] = off & 0xff;\n        buf2[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADD, buf2);\n    }\n\n    //% blockId=SuperBit_Servo4 block=\"Geek舵机| %num|角度 %value\"\n    //% num.min=1 num.max=4 value.min=0 value.max=300\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=20\n    //% subcategory=执行器\n    export function Servo4(num: enServo, value: number): void {\n\n        // 50hz: 20,000 us\n        let us = (value * 1800 * 0.6 / 180 + 600); // 0.6 ~ 2.4\n        let pwm = us * 4096 / 20000;\n        setPwm(num, 0, pwm);\n\n    }\n\n    //% blockId=SuperBit_MotorRun block=\"电机|%index|速度(-255~255) %speed\"\n    //% speed.min=-255 speed.max=255\n    //% subcategory=执行器\n    export function MotorRun(index: enMotors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n\n        let a = index\n        let b = index + 1\n\n        if (a > 10) {\n            if (speed >= 0) {\n                setPwm(a, 0, speed)\n                setPwm(b, 0, 0)\n            } else {\n                setPwm(a, 0, 0)\n                setPwm(b, 0, -speed)\n            }\n        }\n        else {\n            if (speed >= 0) {\n                setPwm(b, 0, speed)\n                setPwm(a, 0, 0)\n            } else {\n                setPwm(b, 0, 0)\n                setPwm(a, 0, -speed)\n            }\n        }\n    }\n\n    //% blockId=\"elecmagnet\" block=\"电磁铁 %pin 切换至 %magState || 磁力 %force\"\n    //% magState.shadow=\"toggleOnOff\"\n    //% force.min=0 force.max=1023\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function elecmagnet(pin: AnalogPin, magState: boolean, force: number = 1023): void {\n\n        if (magState) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(force, 0, 1023, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            force = 0\n        }\n    }\n    //% blockId=\"pinpullup\" block=\"巡线传感器 %pin 引脚为上拉\"\n    //% subcategory=执行器\n    export function pinpullup(pin: PINs): void {\n        switch (pin) {\n            case PINs.P0: pins.setPull(DigitalPin.P0, PinPullMode.PullUp);\n            case PINs.P1: pins.setPull(DigitalPin.P1, PinPullMode.PullUp);\n            case PINs.P2: pins.setPull(DigitalPin.P2, PinPullMode.PullUp);\n            case PINs.P3: pins.setPull(DigitalPin.P3, PinPullMode.PullUp);\n            case PINs.P4: pins.setPull(DigitalPin.P4, PinPullMode.PullUp);\n            case PINs.P5: pins.setPull(DigitalPin.P5, PinPullMode.PullUp);\n            case PINs.P6: pins.setPull(DigitalPin.P6, PinPullMode.PullUp);\n            case PINs.P7: pins.setPull(DigitalPin.P7, PinPullMode.PullUp);\n            case PINs.P8: pins.setPull(DigitalPin.P8, PinPullMode.PullUp);\n            case PINs.P9: pins.setPull(DigitalPin.P9, PinPullMode.PullUp);\n            case PINs.P10: pins.setPull(DigitalPin.P10, PinPullMode.PullUp);\n            case PINs.P11: pins.setPull(DigitalPin.P11, PinPullMode.PullUp);\n            case PINs.P12: pins.setPull(DigitalPin.P12, PinPullMode.PullUp);\n            case PINs.P13: pins.setPull(DigitalPin.P13, PinPullMode.PullUp);\n            case PINs.P14: pins.setPull(DigitalPin.P14, PinPullMode.PullUp);\n            case PINs.P15: pins.setPull(DigitalPin.P15, PinPullMode.PullUp);\n            case PINs.P16: pins.setPull(DigitalPin.P16, PinPullMode.PullUp);\n            case PINs.P19: pins.setPull(DigitalPin.P19, PinPullMode.PullUp);\n            case PINs.P20: pins.setPull(DigitalPin.P20, PinPullMode.PullUp);\n        }\n\n\n    }\n\n    //% blockId=\"laser_controller\" block=\"激光 %pin 切换至 %laserState || 激光 %intensity\"\n    //% laserState.shadow=\"toggleOnOff\"\n    //% intensity.min=0 intensity.max=1023\n    //% expandableArgumentMode=\"toggle\"\n    //% subcategory=执行器\n    export function laserController(pin: AnalogPin, laserState: boolean, intensity: number = 1023): void {\n\n        if (laserState) {\n            pins.analogSetPeriod(pin, 1023)\n            pins.analogWritePin(pin, Math.map(intensity, 0, 1023, 0, 1023))\n        }\n        else {\n            pins.analogWritePin(pin, 0)\n            intensity = 0\n        }\n    }\n\n    //% blockId=\"octopus_ReadWaterLevel\" block=\"水位传感器 %waterlevelpin\"\n    //% subcategory=传感器\n    export function ReadWaterLevel(waterlevelpin: AnalogPin): number {\n        let voltage4 = 0;\n        let waterLevel = 0;\n        voltage4 = pins.map(\n            pins.analogReadPin(waterlevelpin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        waterLevel = voltage4;\n        return Math.round(waterLevel);\n    }\n\n    //% blockId=\"ReadGasConcentration\" block=\"可燃气体传感器 %gasconcentrationpin\"\n    //% subcategory=传感器\n    export function ReadGasConcentration(gasconcentrationpin: AnalogPin): number {\n        let voltage5 = 0;\n        let gasConcentration = 0;\n        voltage5 = pins.map(\n            pins.analogReadPin(gasconcentrationpin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        gasConcentration = voltage5;\n        return Math.round(gasConcentration);\n    }\n\n    //% blockId=\"Readflame\" block=\"火焰传感器 %flamepin\"\n    //% subcategory=传感器\n    export function Readflame(flamepin: AnalogPin): number {\n        let voltage6 = 0;\n        let flame = 0;\n        voltage6 = pins.map(\n            pins.analogReadPin(flamepin),\n            0,\n            1023,\n            0,\n            1023\n        );\n        flame = voltage6;\n        return Math.round(flame);\n    }\n\n    //% blockId=\"ReadGrayLevel\" block=\"灰度传感器 %graylevelpin\"\n    //% subcategory=传感器\n    export function ReadGrayLevel(graylevelpin: AnalogPin): number {\n        let voltage7 = 0;\n        let grayLevel = 0;\n        voltage7 = pins.map(\n            pins.analogReadPin(graylevelpin),\n            0,\n            1023,\n            80,\n            1023\n        );\n        grayLevel = voltage7;\n        return Math.round(grayLevel);\n    }\n\n    //% blockId=\"readWaterTemp\" block=\"防水温度传感器 %waterproofpin\"\n    //% subcategory=传感器\n    export function readWaterTemp(waterproofpin: AnalogPin): number {\n        let voltage22 = 0;\n        let waterProofTemp = 0;\n        voltage22 = pins.analogReadPin(waterproofpin);//%获得原始值\n        if (voltage22 > 1001){ waterProofTemp = 100;}\n        else if (voltage22 > 1000){ waterProofTemp = 98;}\n        else if (voltage22 > 999) { waterProofTemp = 97; }\n        else if (voltage22 > 998) { waterProofTemp = 96; }\n        else if (voltage22 > 997) { waterProofTemp = 95; }\n        else if (voltage22 > 996) { waterProofTemp = 93; }\n        else if (voltage22 > 995) { waterProofTemp = 92; }\n        else if (voltage22 > 994) { waterProofTemp = 91; }\n        else if (voltage22 > 993) { waterProofTemp = 90; }\n        else if (voltage22 > 992) { waterProofTemp = 89; }\n        else if (voltage22 > 991) { waterProofTemp = 88; }\n        else if (voltage22 > 990) { waterProofTemp = 87; }\n        else if (voltage22 > 989) { waterProofTemp = 86; }\n        else if (voltage22 > 988) { waterProofTemp = 85; }\n        else if (voltage22 > 987) { waterProofTemp = 84; }\n        else if (voltage22 > 986) {waterProofTemp = 83; }\n        else if (voltage22 > 985) { waterProofTemp = 82; }\n        else if (voltage22 > 984) { waterProofTemp = 81; }\n        else if (voltage22 > 982) { waterProofTemp = 80; }\n        else if (voltage22 > 981) { waterProofTemp = 79; }\n        else if (voltage22 > 980) { waterProofTemp = 78; }\n        else if (voltage22 > 978) { waterProofTemp = 77; }\n        else if (voltage22 > 977) { waterProofTemp = 76; }\n        else if (voltage22 > 975) { waterProofTemp = 75; }\n        else if (voltage22 > 974) { waterProofTemp = 74; }\n        else if (voltage22 > 972) { waterProofTemp = 73; }\n        else if (voltage22 > 971) { waterProofTemp = 72; }\n        else if (voltage22 > 969) { waterProofTemp = 71; }\n        else if (voltage22 > 967) { waterProofTemp = 70; }\n        else if (voltage22 > 965) { waterProofTemp = 69; }\n        else if (voltage22 > 963) { waterProofTemp = 68; }\n        else if (voltage22 > 961) { waterProofTemp = 67; }\n        else if (voltage22 > 959) { waterProofTemp = 66; }\n        else if (voltage22 > 957) { waterProofTemp = 65; }\n        else if (voltage22 > 955) { waterProofTemp = 64; }\n        else if (voltage22 > 953) { waterProofTemp = 63; }\n        else if (voltage22 > 950) { waterProofTemp = 62; }\n        else if (voltage22 > 948) { waterProofTemp = 61; }\n        else if (voltage22 > 943) { waterProofTemp = 59; }\n        else if (voltage22 > 940) { waterProofTemp = 58; }\n        else if (voltage22 > 937) { waterProofTemp = 57; }\n        else if (voltage22 > 934) { waterProofTemp = 56; }\n        else if (voltage22 > 931) { waterProofTemp = 55; }\n        else if (voltage22 > 928) { waterProofTemp = 54; }\n        else if (voltage22 > 924) { waterProofTemp = 53; }\n        else if (voltage22 > 921) { waterProofTemp = 52; }\n        else if (voltage22 > 917) { waterProofTemp = 51; }\n        else if (voltage22 > 914) { waterProofTemp = 51; }\n        else if (voltage22 > 910) { waterProofTemp = 49; }\n        else if (voltage22 > 906) { waterProofTemp = 48; }\n        else if (voltage22 > 902) { waterProofTemp = 47; }\n        else if (voltage22 > 898) { waterProofTemp = 46; }\n        else if (voltage22 > 893) { waterProofTemp = 45; }\n        else if (voltage22 > 889) { waterProofTemp = 44; }\n        else if (voltage22 > 884) { waterProofTemp = 43; }\n        else if (voltage22 > 879) { waterProofTemp = 42; }\n        else if (voltage22 > 874) { waterProofTemp = 41; }\n        else if (voltage22 > 869) { waterProofTemp = 40; }\n        else if (voltage22 > 864) { waterProofTemp = 39; }\n        else if (voltage22 > 858) { waterProofTemp = 38; }\n        else if (voltage22 > 852) { waterProofTemp = 37; }\n        else if (voltage22 > 846) { waterProofTemp = 36; }\n        else if (voltage22 > 840) { waterProofTemp = 35; }\n        else if (voltage22 > 834) { waterProofTemp = 34; }\n        else if (voltage22 > 827) { waterProofTemp = 33; }\n        else if (voltage22 > 821) { waterProofTemp = 32; }\n        else if (voltage22 > 814) { waterProofTemp = 31; }\n        else if (voltage22 > 806) { waterProofTemp = 30; }\n        else if (voltage22 > 799) { waterProofTemp = 29; }\n        else if (voltage22 > 791) { waterProofTemp = 28; }\n        else if (voltage22 > 784) { waterProofTemp = 27; }\n        else if (voltage22 > 776) { waterProofTemp = 26; }\n        else if (voltage22 > 767) { waterProofTemp = 25; }\n        else if (voltage22 > 759) { waterProofTemp = 24; }\n        else if (voltage22 > 750) { waterProofTemp = 23; }\n        else if (voltage22 > 741) { waterProofTemp = 22; }\n        else if (voltage22 > 732) { waterProofTemp = 21; }\n        else if (voltage22 > 713) { waterProofTemp = 19; }\n        else if (voltage22 > 703) { waterProofTemp = 18; }\n        else if (voltage22 > 692) { waterProofTemp = 17; }\n        else if (voltage22 > 682) { waterProofTemp = 16; }\n        else if (voltage22 > 671) { waterProofTemp = 15; }\n        else if (voltage22 > 661) { waterProofTemp = 14; }\n        else if (voltage22 > 650) { waterProofTemp = 13; }\n        else if (voltage22 > 638) { waterProofTemp = 12; }\n        else if (voltage22 > 627) { waterProofTemp = 11; }\n        else if (voltage22 > 615) { waterProofTemp = 10; }\n        else if (voltage22 > 604) { waterProofTemp = 9; }\n        else if (voltage22 > 592) { waterProofTemp = 8; }\n        else if (voltage22 > 579) { waterProofTemp = 7; }\n        else if (voltage22 > 567) { waterProofTemp = 6; }\n        else if (voltage22 > 555) { waterProofTemp = 5; }\n        else if (voltage22 > 542) { waterProofTemp = 4; }\n        else if (voltage22 > 530) { waterProofTemp = 3; }\n        else if (voltage22 > 517) { waterProofTemp = 2; }\n        else if (voltage22 > 504) { waterProofTemp = 1; }\n        else  { waterProofTemp = 0; }\n        return waterProofTemp;\n    }\n\n    //% blockId=potentiometerRead\n    //% block=\"电位器 %pin\"\n    //% subcategory=传感器\n    export function potentiometerRead(pin: AnalogPin): number {\n        return pins.analogReadPin(pin);\n    }\n\n    //% blockId=buttonState\n    //% block=\"按钮传感器 %pin\"\n    //% subcategory=传感器\n    export function buttonState(pin: DigitalPin): number {\n\n        return pins.digitalReadPin(pin);\n    }\n    //% blockId=followState\n    //% block=\"巡线传感器 %pin\"\n    //% subcategory=传感器\n    export function followState(pin: PINs): number {\n        switch (pin) {\n            case PINs.P0: return pins.digitalReadPin(DigitalPin.P0);\n            case PINs.P1: return pins.digitalReadPin(DigitalPin.P1);\n            case PINs.P2: return pins.digitalReadPin(DigitalPin.P2);\n            case PINs.P3: return pins.digitalReadPin(DigitalPin.P3);\n            case PINs.P4: return pins.digitalReadPin(DigitalPin.P4);\n            case PINs.P5: return pins.digitalReadPin(DigitalPin.P5);\n            case PINs.P6: return pins.digitalReadPin(DigitalPin.P6);\n            case PINs.P7: return pins.digitalReadPin(DigitalPin.P7);\n            case PINs.P8: return pins.digitalReadPin(DigitalPin.P8);\n            case PINs.P9: return pins.digitalReadPin(DigitalPin.P9);\n            case PINs.P10: return pins.digitalReadPin(DigitalPin.P10);\n            case PINs.P11: return pins.digitalReadPin(DigitalPin.P11);\n            case PINs.P12: return pins.digitalReadPin(DigitalPin.P12);\n            case PINs.P13: return pins.digitalReadPin(DigitalPin.P13);\n            case PINs.P14: return pins.digitalReadPin(DigitalPin.P14);\n            case PINs.P15: return pins.digitalReadPin(DigitalPin.P15);\n            case PINs.P16: return pins.digitalReadPin(DigitalPin.P16);\n            case PINs.P19: return pins.digitalReadPin(DigitalPin.P19);\n            case PINs.P20: return pins.digitalReadPin(DigitalPin.P20);\n\n        }\n\n    }\n\n    //% blockId=farState\n    //% block=\"远距离光电传感器 %pin\"\n    //% subcategory=传感器\n    export function farState(pin: DigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    //% blockId=hState\n    //% block=\"霍尔传感器 %pin\"\n    //% subcategory=传感器\n    export function hState(pin: DigitalPin): number {\n        return pins.digitalReadPin(pin);\n    }\n\n    enum LCS_Constants {\n        // Constants\n        ADDRESS = 0x29,\n        ID = 0x12, // Register should be equal to 0x44 for the TCS34721 or TCS34725, or 0x4D for the TCS34723 or TCS34727.\n\n        COMMAND_BIT = 0x80,\n\n        ENABLE = 0x00,\n        ENABLE_AIEN = 0x10, // RGBC Interrupt Enable\n        ENABLE_WEN = 0x08, // Wait enable - Writing 1 activates the wait timer\n        ENABLE_AEN = 0x02, // RGBC Enable - Writing 1 actives the ADC, 0 disables it\n        ENABLE_PON = 0x01, // Power on - Writing 1 activates the internal oscillator, 0 disables it\n        ATIME = 0x01, // Integration time\n        WTIME = 0x03, // Wait time (if ENABLE_WEN is asserted)\n        AILTL = 0x04, // Clear channel lower interrupt threshold\n        AILTH = 0x05,\n        AIHTL = 0x06, // Clear channel upper interrupt threshold\n        AIHTH = 0x07,\n        PERS = 0x0C, // Persistence register - basic SW filtering mechanism for interrupts\n        PERS_NONE = 0x00, // Every RGBC cycle generates an interrupt\n        PERS_1_CYCLE = 0x01, // 1 clean channel value outside threshold range generates an interrupt\n        PERS_2_CYCLE = 0x02, // 2 clean channel values outside threshold range generates an interrupt\n        PERS_3_CYCLE = 0x03, // 3 clean channel values outside threshold range generates an interrupt\n        PERS_5_CYCLE = 0x04, // 5 clean channel values outside threshold range generates an interrupt\n        PERS_10_CYCLE = 0x05, // 10 clean channel values outside threshold range generates an interrupt\n        PERS_15_CYCLE = 0x06, // 15 clean channel values outside threshold range generates an interrupt\n        PERS_20_CYCLE = 0x07, // 20 clean channel values outside threshold range generates an interrupt\n        PERS_25_CYCLE = 0x08, // 25 clean channel values outside threshold range generates an interrupt\n        PERS_30_CYCLE = 0x09, // 30 clean channel values outside threshold range generates an interrupt\n        PERS_35_CYCLE = 0x0A, // 35 clean channel values outside threshold range generates an interrupt\n        PERS_40_CYCLE = 0x0B, // 40 clean channel values outside threshold range generates an interrupt\n        PERS_45_CYCLE = 0x0C, // 45 clean channel values outside threshold range generates an interrupt\n        PERS_50_CYCLE = 0x0D, // 50 clean channel values outside threshold range generates an interrupt\n        PERS_55_CYCLE = 0x0E, // 55 clean channel values outside threshold range generates an interrupt\n        PERS_60_CYCLE = 0x0F, // 60 clean channel values outside threshold range generates an interrupt\n        CONFIG = 0x0D,\n        CONFIG_WLONG = 0x02, // Choose between short and long (12x) wait times via WTIME\n        CONTROL = 0x0F, // Set the gain level for the sensor\n        STATUS = 0x13,\n        STATUS_AINT = 0x10, // RGBC Clean channel interrupt\n        STATUS_AVALID = 0x01, // Indicates that the RGBC channels have completed an integration cycle\n\n        CDATAL = 0x14, // Clear channel data\n        CDATAH = 0x15,\n        RDATAL = 0x16, // Red channel data\n        RDATAH = 0x17,\n        GDATAL = 0x18, // Green channel data\n        GDATAH = 0x19,\n        BDATAL = 0x1A, // Blue channel data\n        BDATAH = 0x1B,\n\n        GAIN_1X = 0x00, //  1x gain\n        GAIN_4X = 0x01, //  4x gain\n        GAIN_16X = 0x02, // 16x gain\n        GAIN_60X = 0x03  // 60x gain\n    }\n\n    let LCS_integration_time_val = 0\n\n    // I2C functions\n\n    function I2C_WriteReg8(addr: number, reg: number, val: number) {\n        let buf3 = pins.createBuffer(2)\n        buf3.setNumber(NumberFormat.UInt8BE, 0, reg)\n        buf3.setNumber(NumberFormat.UInt8BE, 1, val)\n        pins.i2cWriteBuffer(addr, buf3)\n    }\n\n    function I2C_ReadReg8(addr: number, reg: number): number {\n        let buf4 = pins.createBuffer(1)\n        buf4.setNumber(NumberFormat.UInt8BE, 0, reg)\n        pins.i2cWriteBuffer(addr, buf4)\n        buf4 = pins.i2cReadBuffer(addr, 1)\n        return buf4.getNumber(NumberFormat.UInt8BE, 0);\n    }\n\n    function I2C_ReadReg16(addr: number, reg: number): number {\n        let buf5 = pins.createBuffer(1)\n        buf5.setNumber(NumberFormat.UInt8BE, 0, reg)\n        pins.i2cWriteBuffer(addr, buf5)\n        buf5 = pins.i2cReadBuffer(addr, 2)\n        // Little endian\n        return ((buf5.getNumber(NumberFormat.UInt8BE, 1) << 8) | buf5.getNumber(NumberFormat.UInt8BE, 0));\n    }\n    function LCS_get_raw_data(delay: boolean = false): number[] {\n        if (delay) {\n            // Delay for the integration time to allow reading immediately after the previous read.\n            basic.pause((256 - LCS_integration_time_val) * 2.4)\n        }\n\n        let div = (256 - LCS_integration_time_val) * 1024\n        let rgbc = [0, 0, 0, 0]\n        rgbc[0] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.RDATAL)) / div\n        rgbc[1] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.GDATAL)) / div\n        rgbc[2] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.BDATAL)) / div\n        rgbc[3] = I2C_ReadReg16(LCS_Constants.ADDRESS, (LCS_Constants.COMMAND_BIT | LCS_Constants.CDATAL)) / div\n        if (rgbc[0] > 1) {\n            rgbc[0] = 1\n        }\n        if (rgbc[1] > 1) {\n            rgbc[1] = 1\n        }\n        if (rgbc[2] > 1) {\n            rgbc[2] = 1\n        }\n        if (rgbc[3] > 1) {\n            rgbc[3] = 1\n        }\n        return rgbc\n    }\n\n    let font: number[] = [];\n    font[0] = 0x0022d422;\n    font[1] = 0x0022d422;\n    font[2] = 0x0022d422;\n    font[3] = 0x0022d422;\n    font[4] = 0x0022d422;\n    font[5] = 0x0022d422;\n    font[6] = 0x0022d422;\n    font[7] = 0x0022d422;\n    font[8] = 0x0022d422;\n    font[9] = 0x0022d422;\n    font[10] = 0x0022d422;\n    font[11] = 0x0022d422;\n    font[12] = 0x0022d422;\n    font[13] = 0x0022d422;\n    font[14] = 0x0022d422;\n    font[15] = 0x0022d422;\n    font[16] = 0x0022d422;\n    font[17] = 0x0022d422;\n    font[18] = 0x0022d422;\n    font[19] = 0x0022d422;\n    font[20] = 0x0022d422;\n    font[21] = 0x0022d422;\n    font[22] = 0x0022d422;\n    font[23] = 0x0022d422;\n    font[24] = 0x0022d422;\n    font[25] = 0x0022d422;\n    font[26] = 0x0022d422;\n    font[27] = 0x0022d422;\n    font[28] = 0x0022d422;\n    font[29] = 0x0022d422;\n    font[30] = 0x0022d422;\n    font[31] = 0x0022d422;\n    font[32] = 0x00000000;\n    font[33] = 0x000002e0;\n    font[34] = 0x00018060;\n    font[35] = 0x00afabea;\n    font[36] = 0x00aed6ea;\n    font[37] = 0x01991133;\n    font[38] = 0x010556aa;\n    font[39] = 0x00000060;\n    font[40] = 0x000045c0;\n    font[41] = 0x00003a20;\n    font[42] = 0x00051140;\n    font[43] = 0x00023880;\n    font[44] = 0x00002200;\n    font[45] = 0x00021080;\n    font[46] = 0x00000100;\n    font[47] = 0x00111110;\n    font[48] = 0x0007462e;\n    font[49] = 0x00087e40;\n    font[50] = 0x000956b9;\n    font[51] = 0x0005d629;\n    font[52] = 0x008fa54c;\n    font[53] = 0x009ad6b7;\n    font[54] = 0x008ada88;\n    font[55] = 0x00119531;\n    font[56] = 0x00aad6aa;\n    font[57] = 0x0022b6a2;\n    font[58] = 0x00000140;\n    font[59] = 0x00002a00;\n    font[60] = 0x0008a880;\n    font[61] = 0x00052940;\n    font[62] = 0x00022a20;\n    font[63] = 0x0022d422;\n    font[64] = 0x00e4d62e;\n    font[65] = 0x000f14be;\n    font[66] = 0x000556bf;\n    font[67] = 0x0008c62e;\n    font[68] = 0x0007463f;\n    font[69] = 0x0008d6bf;\n    font[70] = 0x000094bf;\n    font[71] = 0x00cac62e;\n    font[72] = 0x000f909f;\n    font[73] = 0x000047f1;\n    font[74] = 0x0017c629;\n    font[75] = 0x0008a89f;\n    font[76] = 0x0008421f;\n    font[77] = 0x01f1105f;\n    font[78] = 0x01f4105f;\n    font[79] = 0x0007462e;\n    font[80] = 0x000114bf;\n    font[81] = 0x000b6526;\n    font[82] = 0x010514bf;\n    font[83] = 0x0004d6b2;\n    font[84] = 0x0010fc21;\n    font[85] = 0x0007c20f;\n    font[86] = 0x00744107;\n    font[87] = 0x01f4111f;\n    font[88] = 0x000d909b;\n    font[89] = 0x00117041;\n    font[90] = 0x0008ceb9;\n    font[91] = 0x0008c7e0;\n    font[92] = 0x01041041;\n    font[93] = 0x000fc620;\n    font[94] = 0x00010440;\n    font[95] = 0x01084210;\n    font[96] = 0x00000820;\n    font[97] = 0x010f4a4c;\n    font[98] = 0x0004529f;\n    font[99] = 0x00094a4c;\n    font[100] = 0x000fd288;\n    font[101] = 0x000956ae;\n    font[102] = 0x000097c4;\n    font[103] = 0x0007d6a2;\n    font[104] = 0x000c109f;\n    font[105] = 0x000003a0;\n    font[106] = 0x0006c200;\n    font[107] = 0x0008289f;\n    font[108] = 0x000841e0;\n    font[109] = 0x01e1105e;\n    font[110] = 0x000e085e;\n    font[111] = 0x00064a4c;\n    font[112] = 0x0002295e;\n    font[113] = 0x000f2944;\n    font[114] = 0x0001085c;\n    font[115] = 0x00012a90;\n    font[116] = 0x010a51e0;\n    font[117] = 0x010f420e;\n    font[118] = 0x00644106;\n    font[119] = 0x01e8221e;\n    font[120] = 0x00093192;\n    font[121] = 0x00222292;\n    font[122] = 0x00095b52;\n    font[123] = 0x0008fc80;\n    font[124] = 0x000003e0;\n    font[125] = 0x000013f1;\n    font[126] = 0x00841080;\n    font[127] = 0x0022d422;\n\n    let _I2CAddr = 0;\n    let _screen = pins.createBuffer(1025);\n    let _buf2 = pins.createBuffer(2);\n    let _buf3 = pins.createBuffer(3);\n    let _buf4 = pins.createBuffer(4);\n    let _ZOOM = 1;\n\n    function cmd1(d: number) {\n        let n = d % 256;\n        pins.i2cWriteNumber(_I2CAddr, n, NumberFormat.UInt16BE);\n    }\n\n    function cmd2(d1: number, d2: number) {\n        _buf3[0] = 0;\n        _buf3[1] = d1;\n        _buf3[2] = d2;\n        pins.i2cWriteBuffer(_I2CAddr, _buf3);\n    }\n\n    function cmd3(d1: number, d2: number, d3: number) {\n        _buf4[0] = 0;\n        _buf4[1] = d1;\n        _buf4[2] = d2;\n        _buf4[3] = d3;\n        pins.i2cWriteBuffer(_I2CAddr, _buf4);\n    }\n\n    function set_pos(col: number = 0, page: number = 0) {\n        cmd1(0xb0 | page) // page number\n        let c = col * (_ZOOM + 1)\n        cmd1(0x00 | (c % 16)) // lower start column address\n        cmd1(0x10 | (c >> 4)) // upper start column address    \n    }\n\n    // clear bit\n    function clrbit(d: number, b: number): number {\n        if (d & (1 << b))\n            d -= (1 << b)\n        return d\n    }\n   \n    /**\n     * show text in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param s is the text will be show, eg: 'Hello!'\n     */\n    //% blockId=\"OLED12864_I2C_SHOWSTRING1\" block=\"显示 文本 在 x %x|y %y|文本 %s\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=80 blockGap=10 color=#0855AA\n    export function showString(x: number, y: number, s: string, color: number = 1) {\n        let col2 = 0\n        let q = 0\n        let ind2 = 0\n        for (let r = 0; r < s.length; r++) {\n            q = font[s.charCodeAt(r)]\n            for (let k = 0; k < 5; k++) {\n                col2 = 0\n                for (let l = 0; l < 5; l++) {\n                    if (q & (1 << (5 * k + l)))\n                        col2 |= (1 << (l + 1))\n                }\n                ind2 = (x + r) * 5 * (_ZOOM + 1) + y * 128 + k * (_ZOOM + 1) + 1\n                if (color == 0)\n                    col2 = 255 - col2\n                _screen[ind2] = col2\n                if (_ZOOM)\n                    _screen[ind2 + 1] = col2\n            }\n        }\n        set_pos(x * 5, y)\n        let ind02 = x * 5 * (_ZOOM + 1) + y * 128\n        let buf7 = _screen.slice(ind02, ind2 + 1)\n        buf7[0] = 0x40\n        pins.i2cWriteBuffer(_I2CAddr, buf7)\n    }\n\n    /**\n     * show a number in OLED\n     * @param x is X alis, eg: 0\n     * @param y is Y alis, eg: 0\n     * @param num is the number will be show, eg: 12\n     * @param color is number color, eg: 1\n     */\n    //% blockId=\"OLED12864_I2C_NUMBER\" block=\"显示 数字 在 x %x|y %y|数字 %num\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=80 blockGap=10 color=#0855AA\n    export function showNumber(x: number, y: number, num: number, color: number = 1) {\n        showString(x, y, num.toString(), color)\n    }\n\n   \n    export function draw() {\n        set_pos()\n        pins.i2cWriteBuffer(_I2CAddr, _screen)\n    }\n\n    /**\n     * clear screen\n     */\n    //% blockId=\"OLED12864_I2C_CLEAR\" block=\"清除\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% weight=63 blockGap=10 color=#0855AA\n    export function clear() {\n        _screen.fill(0)\n        _screen[0] = 0x40\n        draw()\n    }\n\n    /**\n     * OLED initialize\n     * @param addr is i2c addr, eg: 60\n     */\n    //% blockId=\"OLED12864_I2C_init\" block=\"初始化 OLED 地址为 %addr\"\n    //% parts=OLED12864_I2C trackArgs=0\n    //% weight=85 blockGap=10\n    //% group=\"OLED显示屏\" subcategory=执行器\n    //% blockGap=10  color=#0855AA\n    export function init(addr: number) {\n        _I2CAddr = addr;\n        cmd1(0xAE)       // SSD1306_DISPLAYOFF\n        cmd1(0xA4)       // SSD1306_DISPLAYALLON_RESUME\n        cmd2(0xD5, 0xF0) // SSD1306_SETDISPLAYCLOCKDIV\n        cmd2(0xA8, 0x3F) // SSD1306_SETMULTIPLEX\n        cmd2(0xD3, 0x00) // SSD1306_SETDISPLAYOFFSET\n        cmd1(0 | 0x0)    // line #SSD1306_SETSTARTLINE\n        cmd2(0x8D, 0x14) // SSD1306_CHARGEPUMP\n        cmd2(0x20, 0x00) // SSD1306_MEMORYMODE\n        cmd3(0x21, 0, 127) // SSD1306_COLUMNADDR\n        cmd3(0x22, 0, 63)  // SSD1306_PAGEADDR\n        cmd1(0xa0 | 0x1) // SSD1306_SEGREMAP\n        cmd1(0xc8)       // SSD1306_COMSCANDEC\n        cmd2(0xDA, 0x12) // SSD1306_SETCOMPINS\n        cmd2(0x81, 0xCF) // SSD1306_SETCONTRAST\n        cmd2(0xd9, 0xF1) // SSD1306_SETPRECHARGE\n        cmd2(0xDB, 0x40) // SSD1306_SETVCOMDETECT\n        cmd1(0xA6)       // SSD1306_NORMALDISPLAY\n        cmd2(0xD6, 1)    // zoom on\n        cmd1(0xAF)       // SSD1306_DISPLAYON\n        clear()\n        _ZOOM = 1\n    }\n\n    /**\n     * A NeoPixel strip\n     */\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n        /**\n         * Shows all LEDs to a given color (range 0-255 for r, g, b).\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|显示 颜色 %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        showColor(rgb: number) {\n            rgb = rgb >> 0;\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n        /**\n         * Shows a rainbow pattern on all LEDs.\n         * @param startHue the start hue value for the rainbow, eg: 1\n         * @param endHue the end hue value for the rainbow, eg: 360\n         */\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|显示 彩虹 从 %startHue|到 %endHue\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\" \n        //% color=#2699BF blockGap=10\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            startHue = startHue >> 0;\n            endHue = endHue >> 0;\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = Math.idiv(sDist, steps);\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = Math.idiv(lDist, steps);\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let t = 1; t < steps - 1; t++) {\n                    const u = Math.idiv((h1_100 + t * hStep), 100) + 360;\n                    const v = Math.idiv((s1_100 + t * sStep), 100);\n                    const w = Math.idiv((l1_100 + t * lStep), 100);\n                    this.setPixelColor(t, hsl(u, v, w));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n        \n        /**\n         * Set LED to a given color (range 0-255 for r, g, b).\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip,eg: 1\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"%strip|设置 像素 颜色 在 %pixeloffset|到 %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset >> 0, rgb >> 0);\n        }  \n      \n        /**\n         * Send all the changes to the strip.\n         */\n        //% blockId=\"neopixel_show\" block=\"%strip|显示\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        show() {\n            // only supported in beta\n            // ws2812b.setBufferMode(this.pin, this._mode);\n            ws2812b.sendBuffer(this.buf, this.pin);\n        }\n\n        /**\n         * Turn off all LEDs.\n         * You need to call ``show`` to make the changes visible.\n         */\n        //% blockId=\"neopixel_clear\" block=\"%strip|清除\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|设置 亮度 %brightness\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n        /**\n         * Set the pin where the neopixel is connected, defaults to P0.\n         */\n        //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n        //% color=#2699BF blockGap=10\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n       \n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br3 = this.brightness;\n            if (br3 < 255) {\n                red = (red * br3) >> 8;\n                green = (green * br3) >> 8;\n                blue = (blue * br3) >> 8;\n            }\n            const end3 = this.start + this._length;\n            const stride6 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i5 = this.start; i5 < end3; ++i5) {\n                this.setBufferRGB(i5 * stride6, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br4 = this.brightness;\n            if (br4 < 255) {\n                white = (white * br4) >> 8;\n            }\n            let buf8 = this.buf;\n            let end4 = this.start + this._length;\n            for (let i6 = this.start; i6 < end4; ++i6) {\n                let ledoffset3 = i6 * 4;\n                buf8[ledoffset3 + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride7 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride7;\n\n            let red2 = unpackR(rgb);\n            let green2 = unpackG(rgb);\n            let blue2 = unpackB(rgb);\n\n            let br5 = this.brightness;\n            if (br5 < 255) {\n                red2 = (red2 * br5) >> 8;\n                green2 = (green2 * br5) >> 8;\n                blue2 = (blue2 * br5) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red2, green2, blue2)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br6 = this.brightness;\n            if (br6 < 255) {\n                white = (white * br6) >> 8;\n            }\n            let buf9 = this.buf;\n            buf9[pixeloffset + 3] = white;\n        }\n    }\n\n    /**\n     * Create a new NeoPixel driver for `numleds` LEDs.\n     * @param pin the pin where the neopixel is connected.\n     * @param numleds number of leds in the strip, eg: 8,30,60,64\n     */\n    //% blockId=\"neopixel_create\" block=\"灯环 在 端口 %pin|用 %numleds| leds\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% trackArgs=0,2\n    //% blockSetVariable=strip\n    //% color=#2699BF blockGap=10\n    //% weight=51\n    export function create(pin: DigitalPin, numleds: number): Strip {\n        let strip2 = new Strip();\n        let stride8 = NeoPixelMode.RGBW ? 4 : 3;\n        strip2.buf = pins.createBuffer(numleds * stride8);\n        strip2.start = 0;\n        strip2._length = numleds;\n        strip2._mode = NeoPixelMode.RGB;\n        strip2._matrixWidth = 0;\n        strip2.setBrightness(128)\n        strip2.setPin(pin)\n        return strip2;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% blockId=\"neopixel_rgb\" block=\"红 %red|绿 %green|蓝 %blue\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% weight=32\n    //% color=#2699BF blockGap=10\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    /**\n     * Gets the RGB value of a known color\n    */\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n    //% parts=\"neopixel\" subcategory=执行器 group=\"彩灯\"\n    //% weight=32\n    //% color=#2699BF blockGap=10\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n\n    function unpackR(rgb: number): number {\n        let r3 = (rgb >> 16) & 0xFF;\n        return r3;\n    }\n\n    function unpackG(rgb: number): number {\n        let g3 = (rgb >> 8) & 0xFF;\n        return g3;\n    }\n\n    function unpackB(rgb: number): number {\n        let b3 = (rgb) & 0xFF;\n        return b3;\n    }\n\n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c2 = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h12 = Math.idiv(h, 60);//[0,6]\n        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h12 % 2) << 8) + h22) - 256);\n        let x = (c2 * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h12 == 0) {\n            r$ = c2; g$ = x; b$ = 0;\n        } else if (h12 == 1) {\n            r$ = x; g$ = c2; b$ = 0;\n        } else if (h12 == 2) {\n            r$ = 0; g$ = c2; b$ = x;\n        } else if (h12 == 3) {\n            r$ = 0; g$ = x; b$ = c2;\n        } else if (h12 == 4) {\n            r$ = x; g$ = 0; b$ = c2;\n        } else if (h12 == 5) {\n            r$ = c2; g$ = 0; b$ = x;\n        }\n        let m2 = Math.idiv((Math.idiv((l * 2 << 8), 100) - c2), 2);\n        let r4 = r$ + m2;\n        let g4 = g$ + m2;\n        let b4 = b$ + m2;\n        return packRGB(r4, g4, b4);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n}\n","pxt.json":"{\n    \"name\": \"micro:bit  extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"ws2812b\": \"github:microsoft/pxt-ws2812b#v0.1.1\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"4.0.11\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}